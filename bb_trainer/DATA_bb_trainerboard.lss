
DATA_bb_trainerboard.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000c  00800100  000016de  00001772  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000016de  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000c1  0080010c  0080010c  0000177e  2**0
                  ALLOC
  3 .stab         00004d04  00000000  00000000  00001780  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002879  00000000  00000000  00006484  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 5e 05 	jmp	0xabc	; 0xabc <__vector_1>
       8:	0c 94 3b 05 	jmp	0xa76	; 0xa76 <__vector_2>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 60 01 	jmp	0x2c0	; 0x2c0 <__vector_7>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 eb 05 	jmp	0xbd6	; 0xbd6 <__vector_24>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	ee ed       	ldi	r30, 0xDE	; 222
      7c:	f6 e1       	ldi	r31, 0x16	; 22
      7e:	02 c0       	rjmp	.+4      	; 0x84 <.do_copy_data_start>

00000080 <.do_copy_data_loop>:
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0

00000084 <.do_copy_data_start>:
      84:	ac 30       	cpi	r26, 0x0C	; 12
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <.do_copy_data_loop>

0000008a <__do_clear_bss>:
      8a:	11 e0       	ldi	r17, 0x01	; 1
      8c:	ac e0       	ldi	r26, 0x0C	; 12
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	ad 3c       	cpi	r26, 0xCD	; 205
      96:	b1 07       	cpc	r27, r17
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 9b 00 	call	0x136	; 0x136 <main>
      9e:	0c 94 6d 0b 	jmp	0x16da	; 0x16da <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <Ports_Zero>:
void Ports_Zero()
{
  // Disable interupts
  //cli();

  PORTB = 0;
      a6:	15 b8       	out	0x05, r1	; 5
  DDRB =  0;
      a8:	14 b8       	out	0x04, r1	; 4
  PORTC = 0;
      aa:	18 b8       	out	0x08, r1	; 8
  DDRC =  0;
      ac:	17 b8       	out	0x07, r1	; 7
  PORTD = 0;
      ae:	1b b8       	out	0x0b, r1	; 11
  DDRD =  0;
      b0:	1a b8       	out	0x0a, r1	; 10

  // Enable interupts
  //sei();
}
      b2:	08 95       	ret

000000b4 <Switch_Telemetry_Buffers>:

void Switch_Telemetry_Buffers( void )
{
  static uint8_t reading_telemetry_a = true;

  DISABLE_INTERRUPTS();
      b4:	f8 94       	cli

  // Make sure we are not currently being read
  if ( !g_TWI_readInProgress )
      b6:	80 91 6b 01 	lds	r24, 0x016B
      ba:	88 23       	and	r24, r24
      bc:	31 f5       	brne	.+76     	; 0x10a <Switch_Telemetry_Buffers+0x56>
  {
    if ( reading_telemetry_a )
      be:	80 91 00 01 	lds	r24, 0x0100
      c2:	4c e3       	ldi	r20, 0x3C	; 60
      c4:	51 e0       	ldi	r21, 0x01	; 1
      c6:	24 e2       	ldi	r18, 0x24	; 36
      c8:	31 e0       	ldi	r19, 0x01	; 1
      ca:	88 23       	and	r24, r24
      cc:	59 f0       	breq	.+22     	; 0xe4 <Switch_Telemetry_Buffers+0x30>
    {
      gp_telemetry_read = &m_telemetry_b;
      ce:	50 93 74 01 	sts	0x0174, r21
      d2:	40 93 73 01 	sts	0x0173, r20
      gp_telemetry_write = &m_telemetry_a;
      d6:	30 93 76 01 	sts	0x0176, r19
      da:	20 93 75 01 	sts	0x0175, r18

      reading_telemetry_a = false;
      de:	10 92 00 01 	sts	0x0100, r1
      e2:	0b c0       	rjmp	.+22     	; 0xfa <Switch_Telemetry_Buffers+0x46>
    }
    else
    {
      gp_telemetry_read = &m_telemetry_a;
      e4:	30 93 74 01 	sts	0x0174, r19
      e8:	20 93 73 01 	sts	0x0173, r18
      gp_telemetry_write = &m_telemetry_b;
      ec:	50 93 76 01 	sts	0x0176, r21
      f0:	40 93 75 01 	sts	0x0175, r20

      reading_telemetry_a = true;
      f4:	81 e0       	ldi	r24, 0x01	; 1
      f6:	80 93 00 01 	sts	0x0100, r24
    }

    // Do this here because of the interrupt wrappers
    gp_TWI_transmitBuf = (uint8_t*)gp_telemetry_read;
      fa:	80 91 73 01 	lds	r24, 0x0173
      fe:	90 91 74 01 	lds	r25, 0x0174
     102:	90 93 cc 01 	sts	0x01CC, r25
     106:	80 93 cb 01 	sts	0x01CB, r24
  }

  ENABLE_INTERRUPTS();
     10a:	78 94       	sei
}
     10c:	08 95       	ret

0000010e <HwBitTestAndClear>:

uint8_t HwBitTestAndClear(uint8_t *data, uint8_t bitNumber)
{   
     10e:	fc 01       	movw	r30, r24
  uint8_t bitClear;
  cli();
     110:	f8 94       	cli
  bitClear = BIT_TEST(*data, bitNumber); 
     112:	90 81       	ld	r25, Z
     114:	21 e0       	ldi	r18, 0x01	; 1
     116:	30 e0       	ldi	r19, 0x00	; 0
     118:	02 c0       	rjmp	.+4      	; 0x11e <HwBitTestAndClear+0x10>
     11a:	22 0f       	add	r18, r18
     11c:	33 1f       	adc	r19, r19
     11e:	6a 95       	dec	r22
     120:	e2 f7       	brpl	.-8      	; 0x11a <HwBitTestAndClear+0xc>
  BIT_CLEAR(*data, bitNumber);
     122:	82 2f       	mov	r24, r18
     124:	80 95       	com	r24
     126:	89 23       	and	r24, r25
     128:	80 83       	st	Z, r24
  sei();
     12a:	78 94       	sei
     12c:	89 2f       	mov	r24, r25
     12e:	82 23       	and	r24, r18
     130:	09 f0       	breq	.+2      	; 0x134 <HwBitTestAndClear+0x26>
     132:	81 e0       	ldi	r24, 0x01	; 1
  return bitClear;
}
     134:	08 95       	ret

00000136 <main>:
void Ports_Zero( void );

void Switch_Telemetry_Buffers( void );

int main( void )
{
     136:	ef 92       	push	r14
     138:	ff 92       	push	r15
     13a:	1f 93       	push	r17
     13c:	cf 93       	push	r28
     13e:	df 93       	push	r29
  DISABLE_INTERRUPTS();
     140:	f8 94       	cli
  SYSTEM_CLOCK_T  motion_step_time = 0;
  uint8_t TWI_slaveAddress = 0x10;

  uint8_t steps_since_command = 0;

  gp_commands_read = &m_commands;
     142:	8c e0       	ldi	r24, 0x0C	; 12
     144:	91 e0       	ldi	r25, 0x01	; 1
     146:	90 93 7a 01 	sts	0x017A, r25
     14a:	80 93 79 01 	sts	0x0179, r24
  gp_commands_write = &m_commands;
     14e:	90 93 78 01 	sts	0x0178, r25
     152:	80 93 77 01 	sts	0x0177, r24
  gp_TWI_receive_buf = (uint8_t*)&m_commands;
     156:	90 93 ca 01 	sts	0x01CA, r25
     15a:	80 93 c9 01 	sts	0x01C9, r24

  // After this these pointers are maintained in Switch_Telemetry_Buffer()
  gp_telemetry_read = &m_telemetry_a;
     15e:	24 e2       	ldi	r18, 0x24	; 36
     160:	31 e0       	ldi	r19, 0x01	; 1
     162:	30 93 74 01 	sts	0x0174, r19
     166:	20 93 73 01 	sts	0x0173, r18
  gp_telemetry_write = &m_telemetry_b;
     16a:	8c e3       	ldi	r24, 0x3C	; 60
     16c:	91 e0       	ldi	r25, 0x01	; 1
     16e:	90 93 76 01 	sts	0x0176, r25
     172:	80 93 75 01 	sts	0x0175, r24
  gp_TWI_transmitBuf = (uint8_t*)gp_telemetry_read;
     176:	30 93 cc 01 	sts	0x01CC, r19
     17a:	20 93 cb 01 	sts	0x01CB, r18
  SYSTEM_CLOCK_T  motion_test_time = MOTION_TEST_DELAY;
  uint8_t motors_state = 1;
#endif

  // Hardware Init
  Ports_Zero();
     17e:	0e 94 53 00 	call	0xa6	; 0xa6 <Ports_Zero>
  Motors_Init();
     182:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <Motors_Init>

  Motion_Control_Init();
     186:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <Motion_Control_Init>
  Shaft_Encoders_Init();
     18a:	0e 94 2a 05 	call	0xa54	; 0xa54 <Shaft_Encoders_Init>
  System_Clock_Init();
     18e:	0e 94 18 01 	call	0x230	; 0x230 <System_Clock_Init>
  TWI_Slave_Initialise( TWI_slaveAddress << TWI_ADR_BITS );
     192:	80 e2       	ldi	r24, 0x20	; 32
     194:	0e 94 80 05 	call	0xb00	; 0xb00 <TWI_Slave_Initialise>
  TWI_Start_Transceiver();
     198:	0e 94 ba 05 	call	0xb74	; 0xb74 <TWI_Start_Transceiver>


  // Turn on the Motors
#if MOT_CMD_ENABLED
  Motors_Enable();
     19c:	0e 94 9c 04 	call	0x938	; 0x938 <Motors_Enable>
#else
  Motors_Disable();
#endif

  ENABLE_INTERRUPTS();
     1a0:	78 94       	sei
     1a2:	c0 e0       	ldi	r28, 0x00	; 0
     1a4:	d0 e0       	ldi	r29, 0x00	; 0
     1a6:	10 e0       	ldi	r17, 0x00	; 0
        steps_since_command = 0;

        Motion_Control_Set_Velocity( gp_commands_read->linear_velocity, 
            gp_commands_read->angular_velocity );

        gp_commands_read->linear_velocity = I2C_INVALID_VELOCITY;
     1a8:	e1 2c       	mov	r14, r1
     1aa:	80 e8       	ldi	r24, 0x80	; 128
     1ac:	f8 2e       	mov	r15, r24

  ENABLE_INTERRUPTS();

  for (;;)
  { 
    if ( Clock_Diff(motion_step_time, g_system_clock) <= 0 )
     1ae:	60 91 54 01 	lds	r22, 0x0154
     1b2:	70 91 55 01 	lds	r23, 0x0155
     1b6:	ce 01       	movw	r24, r28
     1b8:	0e 94 2c 01 	call	0x258	; 0x258 <Clock_Diff>
     1bc:	16 16       	cp	r1, r22
     1be:	17 06       	cpc	r1, r23
     1c0:	18 06       	cpc	r1, r24
     1c2:	19 06       	cpc	r1, r25
     1c4:	8c f0       	brlt	.+34     	; 0x1e8 <main+0xb2>
    {
      Switch_Telemetry_Buffers();
     1c6:	0e 94 5a 00 	call	0xb4	; 0xb4 <Switch_Telemetry_Buffers>

      Motion_Control_Run_Step();
     1ca:	0e 94 12 04 	call	0x824	; 0x824 <Motion_Control_Run_Step>

      motion_step_time += MOTION_STEP_DELAY;
      motion_step_time %= SYSTEM_CLOCK_MAX;
     1ce:	ce 01       	movw	r24, r28
     1d0:	44 96       	adiw	r24, 0x14	; 20
     1d2:	60 e6       	ldi	r22, 0x60	; 96
     1d4:	7a ee       	ldi	r23, 0xEA	; 234
     1d6:	0e 94 31 08 	call	0x1062	; 0x1062 <__udivmodhi4>
     1da:	ec 01       	movw	r28, r24
      steps_since_command++;
     1dc:	1f 5f       	subi	r17, 0xFF	; 255

      if ( steps_since_command > MAX_STEPS_BETWEEN_COMMANDS )
     1de:	1a 31       	cpi	r17, 0x1A	; 26
     1e0:	18 f0       	brcs	.+6      	; 0x1e8 <main+0xb2>
      { 
        Motion_Control_Stop();
     1e2:	0e 94 90 02 	call	0x520	; 0x520 <Motion_Control_Stop>
     1e6:	10 e0       	ldi	r17, 0x00	; 0
        steps_since_command = 0;
      }
    }

    if ( g_TWI_writeComplete )
     1e8:	80 91 6a 01 	lds	r24, 0x016A
     1ec:	88 23       	and	r24, r24
     1ee:	f9 f2       	breq	.-66     	; 0x1ae <main+0x78>
    {
      if ( ( gp_commands_read->linear_velocity != I2C_INVALID_VELOCITY ) &&
     1f0:	e0 91 79 01 	lds	r30, 0x0179
     1f4:	f0 91 7a 01 	lds	r31, 0x017A
     1f8:	80 81       	ld	r24, Z
     1fa:	91 81       	ldd	r25, Z+1	; 0x01
     1fc:	80 50       	subi	r24, 0x00	; 0
     1fe:	90 48       	sbci	r25, 0x80	; 128
     200:	a1 f0       	breq	.+40     	; 0x22a <main+0xf4>
     202:	82 81       	ldd	r24, Z+2	; 0x02
     204:	93 81       	ldd	r25, Z+3	; 0x03
     206:	80 50       	subi	r24, 0x00	; 0
     208:	90 48       	sbci	r25, 0x80	; 128
     20a:	79 f0       	breq	.+30     	; 0x22a <main+0xf4>
          ( gp_commands_read->angular_velocity != I2C_INVALID_VELOCITY ) )
      {
        steps_since_command = 0;

        Motion_Control_Set_Velocity( gp_commands_read->linear_velocity, 
     20c:	80 81       	ld	r24, Z
     20e:	91 81       	ldd	r25, Z+1	; 0x01
     210:	62 81       	ldd	r22, Z+2	; 0x02
     212:	73 81       	ldd	r23, Z+3	; 0x03
     214:	0e 94 da 01 	call	0x3b4	; 0x3b4 <Motion_Control_Set_Velocity>
            gp_commands_read->angular_velocity );

        gp_commands_read->linear_velocity = I2C_INVALID_VELOCITY;
     218:	e0 91 79 01 	lds	r30, 0x0179
     21c:	f0 91 7a 01 	lds	r31, 0x017A
     220:	f1 82       	std	Z+1, r15	; 0x01
     222:	e0 82       	st	Z, r14
        gp_commands_read->angular_velocity = I2C_INVALID_VELOCITY;
     224:	f3 82       	std	Z+3, r15	; 0x03
     226:	e2 82       	std	Z+2, r14	; 0x02
     228:	10 e0       	ldi	r17, 0x00	; 0
      }

      g_TWI_writeComplete = false;
     22a:	10 92 6a 01 	sts	0x016A, r1
     22e:	bf cf       	rjmp	.-130    	; 0x1ae <main+0x78>

00000230 <System_Clock_Init>:
	compare_match = 124; // 1000 Hz

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	byte = ( unsigned char ) ( compare_match & ( unsigned long ) 0xff );
	OCR2A = byte;
     230:	8c e7       	ldi	r24, 0x7C	; 124
     232:	80 93 b3 00 	sts	0x00B3, r24

	/* Setup clock source and compare match behaviour. */
	TCCR2A = _BV(WGM21); // CTC
     236:	82 e0       	ldi	r24, 0x02	; 2
     238:	80 93 b0 00 	sts	0x00B0, r24
    TCCR2B = _BV(CS22);  // 64 Prescale
     23c:	84 e0       	ldi	r24, 0x04	; 4
     23e:	80 93 b1 00 	sts	0x00B1, r24
    BIT_CLEAR ( PRR, PRTIM2 );
     242:	e4 e6       	ldi	r30, 0x64	; 100
     244:	f0 e0       	ldi	r31, 0x00	; 0
     246:	80 81       	ld	r24, Z
     248:	8f 7b       	andi	r24, 0xBF	; 191
     24a:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	byte = TIMSK2;
     24c:	e0 e7       	ldi	r30, 0x70	; 112
     24e:	f0 e0       	ldi	r31, 0x00	; 0
     250:	80 81       	ld	r24, Z
	byte |= _BV(OCIE2A); // Enable Timer Interupt
     252:	82 60       	ori	r24, 0x02	; 2
	TIMSK2 = byte;
     254:	80 83       	st	Z, r24
}
     256:	08 95       	ret

00000258 <Clock_Diff>:

/* This function returns the value of time1-time2 corrected for roll over at
 * SYSTEM_CLOCK_MAX. Differences over SYSTEM_CLOCK_MAX/2 are considered roll-over.
 */
int32_t Clock_Diff(SYSTEM_CLOCK_T time1, SYSTEM_CLOCK_T time2)
{
     258:	ef 92       	push	r14
     25a:	ff 92       	push	r15
     25c:	0f 93       	push	r16
     25e:	1f 93       	push	r17
     260:	9b 01       	movw	r18, r22
    int32_t time_diff;

    time_diff = (int32_t)time1 - (int32_t)time2;
     262:	7c 01       	movw	r14, r24
     264:	00 e0       	ldi	r16, 0x00	; 0
     266:	10 e0       	ldi	r17, 0x00	; 0
     268:	40 e0       	ldi	r20, 0x00	; 0
     26a:	50 e0       	ldi	r21, 0x00	; 0
     26c:	e2 1a       	sub	r14, r18
     26e:	f3 0a       	sbc	r15, r19
     270:	04 0b       	sbc	r16, r20
     272:	15 0b       	sbc	r17, r21

    if ( time_diff > (SYSTEM_CLOCK_MAX / 2) )
     274:	81 e3       	ldi	r24, 0x31	; 49
     276:	e8 16       	cp	r14, r24
     278:	85 e7       	ldi	r24, 0x75	; 117
     27a:	f8 06       	cpc	r15, r24
     27c:	80 e0       	ldi	r24, 0x00	; 0
     27e:	08 07       	cpc	r16, r24
     280:	80 e0       	ldi	r24, 0x00	; 0
     282:	18 07       	cpc	r17, r24
     284:	2c f0       	brlt	.+10     	; 0x290 <Clock_Diff+0x38>
    {
        time_diff -= SYSTEM_CLOCK_MAX;
     286:	80 ea       	ldi	r24, 0xA0	; 160
     288:	95 e1       	ldi	r25, 0x15	; 21
     28a:	af ef       	ldi	r26, 0xFF	; 255
     28c:	bf ef       	ldi	r27, 0xFF	; 255
     28e:	0d c0       	rjmp	.+26     	; 0x2aa <Clock_Diff+0x52>
    }
    else if ( time_diff < (-1 * SYSTEM_CLOCK_MAX / 2) )
     290:	90 ed       	ldi	r25, 0xD0	; 208
     292:	e9 16       	cp	r14, r25
     294:	9a e8       	ldi	r25, 0x8A	; 138
     296:	f9 06       	cpc	r15, r25
     298:	9f ef       	ldi	r25, 0xFF	; 255
     29a:	09 07       	cpc	r16, r25
     29c:	9f ef       	ldi	r25, 0xFF	; 255
     29e:	19 07       	cpc	r17, r25
     2a0:	44 f4       	brge	.+16     	; 0x2b2 <Clock_Diff+0x5a>
    {
        time_diff += SYSTEM_CLOCK_MAX;
     2a2:	80 e6       	ldi	r24, 0x60	; 96
     2a4:	9a ee       	ldi	r25, 0xEA	; 234
     2a6:	a0 e0       	ldi	r26, 0x00	; 0
     2a8:	b0 e0       	ldi	r27, 0x00	; 0
     2aa:	e8 0e       	add	r14, r24
     2ac:	f9 1e       	adc	r15, r25
     2ae:	0a 1f       	adc	r16, r26
     2b0:	1b 1f       	adc	r17, r27
    }

    return time_diff;
}
     2b2:	b7 01       	movw	r22, r14
     2b4:	c8 01       	movw	r24, r16
     2b6:	1f 91       	pop	r17
     2b8:	0f 91       	pop	r16
     2ba:	ff 90       	pop	r15
     2bc:	ef 90       	pop	r14
     2be:	08 95       	ret

000002c0 <__vector_7>:

ISR( TIMER2_COMPA_vect )
{
     2c0:	1f 92       	push	r1
     2c2:	0f 92       	push	r0
     2c4:	0f b6       	in	r0, 0x3f	; 63
     2c6:	0f 92       	push	r0
     2c8:	11 24       	eor	r1, r1
     2ca:	2f 93       	push	r18
     2cc:	3f 93       	push	r19
     2ce:	5f 93       	push	r21
     2d0:	6f 93       	push	r22
     2d2:	7f 93       	push	r23
     2d4:	8f 93       	push	r24
     2d6:	9f 93       	push	r25
     2d8:	af 93       	push	r26
     2da:	bf 93       	push	r27
    ++g_system_clock;
     2dc:	80 91 54 01 	lds	r24, 0x0154
     2e0:	90 91 55 01 	lds	r25, 0x0155
     2e4:	01 96       	adiw	r24, 0x01	; 1
     2e6:	90 93 55 01 	sts	0x0155, r25
     2ea:	80 93 54 01 	sts	0x0154, r24

    g_system_clock %= SYSTEM_CLOCK_MAX;
     2ee:	80 91 54 01 	lds	r24, 0x0154
     2f2:	90 91 55 01 	lds	r25, 0x0155
     2f6:	60 e6       	ldi	r22, 0x60	; 96
     2f8:	7a ee       	ldi	r23, 0xEA	; 234
     2fa:	0e 94 31 08 	call	0x1062	; 0x1062 <__udivmodhi4>
     2fe:	90 93 55 01 	sts	0x0155, r25
     302:	80 93 54 01 	sts	0x0154, r24
}
     306:	bf 91       	pop	r27
     308:	af 91       	pop	r26
     30a:	9f 91       	pop	r25
     30c:	8f 91       	pop	r24
     30e:	7f 91       	pop	r23
     310:	6f 91       	pop	r22
     312:	5f 91       	pop	r21
     314:	3f 91       	pop	r19
     316:	2f 91       	pop	r18
     318:	0f 90       	pop	r0
     31a:	0f be       	out	0x3f, r0	; 63
     31c:	0f 90       	pop	r0
     31e:	1f 90       	pop	r1
     320:	18 95       	reti

00000322 <Motion_Control_Set_Acceleration>:
 *  @param  angular_acceleration    In ticks/sec^2
 *
 */
void    Motion_Control_Set_Acceleration(    uint16_t linear_acceleration, 
                                            uint16_t angular_acceleration )
{
     322:	98 2f       	mov	r25, r24
     324:	26 2f       	mov	r18, r22
    // s15.0 -> s7.8 conversion also scaling for update rate
    m_linear_acceleration = ( linear_acceleration * 256 ) / MOTION_CONTROL_UPDATE_RATE_HZ;
     326:	80 e0       	ldi	r24, 0x00	; 0
     328:	62 e3       	ldi	r22, 0x32	; 50
     32a:	70 e0       	ldi	r23, 0x00	; 0
     32c:	0e 94 31 08 	call	0x1062	; 0x1062 <__udivmodhi4>
     330:	70 93 a2 01 	sts	0x01A2, r23
     334:	60 93 a1 01 	sts	0x01A1, r22
    
    // s15.0 -> s7.8 conversion also scaling for update rate 
    m_angular_acceleration = ( angular_acceleration * 256 ) / MOTION_CONTROL_UPDATE_RATE_HZ;
     338:	80 e0       	ldi	r24, 0x00	; 0
     33a:	92 2f       	mov	r25, r18
     33c:	62 e3       	ldi	r22, 0x32	; 50
     33e:	70 e0       	ldi	r23, 0x00	; 0
     340:	0e 94 31 08 	call	0x1062	; 0x1062 <__udivmodhi4>
     344:	70 93 a4 01 	sts	0x01A4, r23
     348:	60 93 a3 01 	sts	0x01A3, r22
}
     34c:	08 95       	ret

0000034e <Motion_Control_Init_Acceleration>:

/** Sets the default accelerations per #defines.
 */
void    Motion_Control_Init_Acceleration( void )
{
    Motion_Control_Set_Acceleration(    MOTION_CONTROL_DEFAULT_LINEAR_ACCEL, 
     34e:	84 e1       	ldi	r24, 0x14	; 20
     350:	90 e0       	ldi	r25, 0x00	; 0
     352:	66 e1       	ldi	r22, 0x16	; 22
     354:	70 e0       	ldi	r23, 0x00	; 0
     356:	0e 94 91 01 	call	0x322	; 0x322 <Motion_Control_Set_Acceleration>
                                        MOTION_CONTROL_DEFAULT_ANGULAR_ACCEL );
}
     35a:	08 95       	ret

0000035c <Motion_Control_Init_State>:

/** This function initializes a Motion_State_t structure, using #defined defaults
 *  for the PID tuning parameters.
 */
void Motion_Control_Init_State( volatile Motion_State_t *p_state )
{
     35c:	fc 01       	movw	r30, r24
    // Reset motion state
    p_state->angular_velocity = 0;
     35e:	13 82       	std	Z+3, r1	; 0x03
     360:	12 82       	std	Z+2, r1	; 0x02
    p_state->angular_velocity_setpoint = 0;
     362:	11 82       	std	Z+1, r1	; 0x01
     364:	10 82       	st	Z, r1

    p_state->linear_velocity = 0;
     366:	17 82       	std	Z+7, r1	; 0x07
     368:	16 82       	std	Z+6, r1	; 0x06
    p_state->linear_velocity_setpoint = 0;
     36a:	15 82       	std	Z+5, r1	; 0x05
     36c:	14 82       	std	Z+4, r1	; 0x04

    p_state->encoder_setpoint = 0;
     36e:	10 86       	std	Z+8, r1	; 0x08
     370:	11 86       	std	Z+9, r1	; 0x09
     372:	12 86       	std	Z+10, r1	; 0x0a
     374:	13 86       	std	Z+11, r1	; 0x0b
    p_state->encoder = 0;
     376:	14 86       	std	Z+12, r1	; 0x0c
     378:	15 86       	std	Z+13, r1	; 0x0d
     37a:	16 86       	std	Z+14, r1	; 0x0e
     37c:	17 86       	std	Z+15, r1	; 0x0f

    // PID defaults
    p_state->pid.kp = MOTION_CONTROL_KP;
     37e:	84 e1       	ldi	r24, 0x14	; 20
     380:	84 8f       	std	Z+28, r24	; 0x1c
    p_state->pid.kd = MOTION_CONTROL_KD;
     382:	82 e0       	ldi	r24, 0x02	; 2
     384:	85 8f       	std	Z+29, r24	; 0x1d
    p_state->pid.ki = MOTION_CONTROL_KI;
     386:	85 e0       	ldi	r24, 0x05	; 5
     388:	86 8f       	std	Z+30, r24	; 0x1e
    p_state->pid.ko = MOTION_CONTROL_KO;
     38a:	81 e0       	ldi	r24, 0x01	; 1
     38c:	87 8f       	std	Z+31, r24	; 0x1f
    p_state->pid.max_correction = MOTION_CONTROL_MAX_CORRECTION;
     38e:	8f ef       	ldi	r24, 0xFF	; 255
     390:	90 e0       	ldi	r25, 0x00	; 0
     392:	93 a3       	std	Z+35, r25	; 0x23
     394:	82 a3       	std	Z+34, r24	; 0x22
    p_state->pid.max_i_error = MOTION_CONTROL_MAX_I_ERROR;
     396:	80 e3       	ldi	r24, 0x30	; 48
     398:	90 e0       	ldi	r25, 0x00	; 0
     39a:	91 a3       	std	Z+33, r25	; 0x21
     39c:	80 a3       	std	Z+32, r24	; 0x20

    // Reset PID state
    p_state->pid.setpoint = 0;
     39e:	13 8a       	std	Z+19, r1	; 0x13
     3a0:	12 8a       	std	Z+18, r1	; 0x12
    p_state->pid.error = 0;
     3a2:	15 8a       	std	Z+21, r1	; 0x15
     3a4:	14 8a       	std	Z+20, r1	; 0x14
    p_state->pid.d_error = 0;
     3a6:	11 8e       	std	Z+25, r1	; 0x19
     3a8:	10 8e       	std	Z+24, r1	; 0x18
    p_state->pid.i_error = 0;
     3aa:	13 8e       	std	Z+27, r1	; 0x1b
     3ac:	12 8e       	std	Z+26, r1	; 0x1a
    p_state->pid.prev_error = 0;
     3ae:	17 8a       	std	Z+23, r1	; 0x17
     3b0:	16 8a       	std	Z+22, r1	; 0x16
}
     3b2:	08 95       	ret

000003b4 <Motion_Control_Set_Velocity>:
/** Set left and right motion structures up for the new velocities.
 *  @param  linear_velocity     New base linear velocity in ticks/sec
 *  @param  angular_velocity    New base angular velocity in ticks/sec
 */
void Motion_Control_Set_Velocity(   int16_t linear_velocity, int16_t angular_velocity )
{
     3b4:	2f 92       	push	r2
     3b6:	3f 92       	push	r3
     3b8:	4f 92       	push	r4
     3ba:	5f 92       	push	r5
     3bc:	6f 92       	push	r6
     3be:	7f 92       	push	r7
     3c0:	8f 92       	push	r8
     3c2:	9f 92       	push	r9
     3c4:	af 92       	push	r10
     3c6:	bf 92       	push	r11
     3c8:	cf 92       	push	r12
     3ca:	df 92       	push	r13
     3cc:	ef 92       	push	r14
     3ce:	ff 92       	push	r15
     3d0:	0f 93       	push	r16
     3d2:	1f 93       	push	r17
     3d4:	cf 93       	push	r28
     3d6:	df 93       	push	r29
     3d8:	ec 01       	movw	r28, r24
     3da:	6b 01       	movw	r12, r22
    int32_t new_linear_velocity, new_angular_velocity, total_velocity;

    // s15.0 -> s7.8 conversion also scaling for update rate
    new_linear_velocity =   ( (int32_t)linear_velocity * 256 ) /    MOTION_CONTROL_UPDATE_RATE_HZ;
     3dc:	be 01       	movw	r22, r28
     3de:	88 27       	eor	r24, r24
     3e0:	77 fd       	sbrc	r23, 7
     3e2:	80 95       	com	r24
     3e4:	98 2f       	mov	r25, r24
     3e6:	98 2f       	mov	r25, r24
     3e8:	87 2f       	mov	r24, r23
     3ea:	76 2f       	mov	r23, r22
     3ec:	66 27       	eor	r22, r22
     3ee:	22 e3       	ldi	r18, 0x32	; 50
     3f0:	30 e0       	ldi	r19, 0x00	; 0
     3f2:	40 e0       	ldi	r20, 0x00	; 0
     3f4:	50 e0       	ldi	r21, 0x00	; 0
     3f6:	0e 94 58 08 	call	0x10b0	; 0x10b0 <__divmodsi4>
     3fa:	b2 2e       	mov	r11, r18
     3fc:	a3 2e       	mov	r10, r19
     3fe:	54 2e       	mov	r5, r20
     400:	45 2e       	mov	r4, r21
     402:	62 2e       	mov	r6, r18
     404:	73 2e       	mov	r7, r19

    // Each wheel gets 1/2 the angular rate
    new_angular_velocity =  ( (int32_t)angular_velocity * 256 ) / ( MOTION_CONTROL_UPDATE_RATE_HZ * 2 );
     406:	b6 01       	movw	r22, r12
     408:	88 27       	eor	r24, r24
     40a:	77 fd       	sbrc	r23, 7
     40c:	80 95       	com	r24
     40e:	98 2f       	mov	r25, r24
     410:	98 2f       	mov	r25, r24
     412:	87 2f       	mov	r24, r23
     414:	76 2f       	mov	r23, r22
     416:	66 27       	eor	r22, r22
     418:	24 e6       	ldi	r18, 0x64	; 100
     41a:	30 e0       	ldi	r19, 0x00	; 0
     41c:	40 e0       	ldi	r20, 0x00	; 0
     41e:	50 e0       	ldi	r21, 0x00	; 0
     420:	0e 94 58 08 	call	0x10b0	; 0x10b0 <__divmodsi4>
     424:	92 2e       	mov	r9, r18
     426:	83 2e       	mov	r8, r19
     428:	34 2e       	mov	r3, r20
     42a:	25 2e       	mov	r2, r21
     42c:	e2 2f       	mov	r30, r18
     42e:	43 2f       	mov	r20, r19

    total_velocity = abs( linear_velocity ) + abs( angular_velocity / 2 );
     430:	c6 01       	movw	r24, r12
     432:	62 e0       	ldi	r22, 0x02	; 2
     434:	70 e0       	ldi	r23, 0x00	; 0
     436:	0e 94 45 08 	call	0x108a	; 0x108a <__divmodhi4>
     43a:	cb 01       	movw	r24, r22
     43c:	77 ff       	sbrs	r23, 7
     43e:	03 c0       	rjmp	.+6      	; 0x446 <Motion_Control_Set_Velocity+0x92>
     440:	90 95       	com	r25
     442:	81 95       	neg	r24
     444:	9f 4f       	sbci	r25, 0xFF	; 255
     446:	9e 01       	movw	r18, r28
     448:	d7 ff       	sbrs	r29, 7
     44a:	04 c0       	rjmp	.+8      	; 0x454 <Motion_Control_Set_Velocity+0xa0>
     44c:	22 27       	eor	r18, r18
     44e:	33 27       	eor	r19, r19
     450:	2c 1b       	sub	r18, r28
     452:	3d 0b       	sbc	r19, r29
     454:	28 0f       	add	r18, r24
     456:	39 1f       	adc	r19, r25
     458:	79 01       	movw	r14, r18
     45a:	00 27       	eor	r16, r16
     45c:	f7 fc       	sbrc	r15, 7
     45e:	00 95       	com	r16
     460:	10 2f       	mov	r17, r16

    if ( total_velocity > m_max_velocity )  // Exceeding wheel speed limits
     462:	80 91 9f 01 	lds	r24, 0x019F
     466:	90 91 a0 01 	lds	r25, 0x01A0
     46a:	a0 e0       	ldi	r26, 0x00	; 0
     46c:	b0 e0       	ldi	r27, 0x00	; 0
     46e:	8e 15       	cp	r24, r14
     470:	9f 05       	cpc	r25, r15
     472:	a0 07       	cpc	r26, r16
     474:	b1 07       	cpc	r27, r17
     476:	1c f5       	brge	.+70     	; 0x4be <Motion_Control_Set_Velocity+0x10a>
    {
        // Reduce both velocities by the "overage ratio"
        new_linear_velocity = ( ( new_linear_velocity * m_max_velocity ) / total_velocity );
     478:	20 91 9f 01 	lds	r18, 0x019F
     47c:	30 91 a0 01 	lds	r19, 0x01A0
     480:	40 e0       	ldi	r20, 0x00	; 0
     482:	50 e0       	ldi	r21, 0x00	; 0
     484:	6b 2d       	mov	r22, r11
     486:	7a 2d       	mov	r23, r10
     488:	85 2d       	mov	r24, r5
     48a:	94 2d       	mov	r25, r4
     48c:	0e 94 12 08 	call	0x1024	; 0x1024 <__mulsi3>
     490:	a8 01       	movw	r20, r16
     492:	97 01       	movw	r18, r14
     494:	0e 94 58 08 	call	0x10b0	; 0x10b0 <__divmodsi4>
     498:	39 01       	movw	r6, r18
        new_angular_velocity = ( ( new_angular_velocity * m_max_velocity ) / total_velocity );
     49a:	20 91 9f 01 	lds	r18, 0x019F
     49e:	30 91 a0 01 	lds	r19, 0x01A0
     4a2:	40 e0       	ldi	r20, 0x00	; 0
     4a4:	50 e0       	ldi	r21, 0x00	; 0
     4a6:	69 2d       	mov	r22, r9
     4a8:	78 2d       	mov	r23, r8
     4aa:	83 2d       	mov	r24, r3
     4ac:	92 2d       	mov	r25, r2
     4ae:	0e 94 12 08 	call	0x1024	; 0x1024 <__mulsi3>
     4b2:	a8 01       	movw	r20, r16
     4b4:	97 01       	movw	r18, r14
     4b6:	0e 94 58 08 	call	0x10b0	; 0x10b0 <__divmodsi4>
     4ba:	e2 2f       	mov	r30, r18
     4bc:	43 2f       	mov	r20, r19
//        linear_velocity = ( (int32_t)( (int32_t) linear_velocity * (int32_t)m_max_velocity ) / total_velocity );
//        angular_velocity = ( (int32_t)( (int32_t) angular_velocity * (int32_t)m_max_velocity ) / total_velocity );
    }

    // Positive angular velocity causes the right wheel to spin faster.
    Motion_Control_Set_Update_Velocity( (int16_t)new_linear_velocity, -1 * new_angular_velocity, &g_left_wheel_motion );
     4be:	8e 2f       	mov	r24, r30
     4c0:	94 2f       	mov	r25, r20
     4c2:	44 27       	eor	r20, r20
     4c4:	55 27       	eor	r21, r21
     4c6:	48 1b       	sub	r20, r24
     4c8:	59 0b       	sbc	r21, r25

void    Motion_Control_Set_Update_Velocity( int16_t linear_velocity,    // s7.8 ticks/update
                                            int16_t angular_velocity,   // s7.8 ticks/update
                                            volatile Motion_State_t *p_state )
{
    p_state->linear_velocity_setpoint = linear_velocity;
     4ca:	70 92 aa 01 	sts	0x01AA, r7
     4ce:	60 92 a9 01 	sts	0x01A9, r6
    p_state->angular_velocity_setpoint = angular_velocity;
     4d2:	50 93 a6 01 	sts	0x01A6, r21
     4d6:	40 93 a5 01 	sts	0x01A5, r20

void    Motion_Control_Set_Update_Velocity( int16_t linear_velocity,    // s7.8 ticks/update
                                            int16_t angular_velocity,   // s7.8 ticks/update
                                            volatile Motion_State_t *p_state )
{
    p_state->linear_velocity_setpoint = linear_velocity;
     4da:	70 92 80 01 	sts	0x0180, r7
     4de:	60 92 7f 01 	sts	0x017F, r6
    p_state->angular_velocity_setpoint = angular_velocity;
     4e2:	90 93 7c 01 	sts	0x017C, r25
     4e6:	80 93 7b 01 	sts	0x017B, r24
    // Positive angular velocity causes the right wheel to spin faster.
    Motion_Control_Set_Update_Velocity( (int16_t)new_linear_velocity, -1 * new_angular_velocity, &g_left_wheel_motion );
    Motion_Control_Set_Update_Velocity( (int16_t)new_linear_velocity, new_angular_velocity, &g_right_wheel_motion );

    // Copy data to outgoing telemetry
    gp_telemetry_write->linear_velocity = linear_velocity;
     4ea:	e0 91 75 01 	lds	r30, 0x0175
     4ee:	f0 91 76 01 	lds	r31, 0x0176
     4f2:	d1 83       	std	Z+1, r29	; 0x01
     4f4:	c0 83       	st	Z, r28
    gp_telemetry_write->angular_velocity = angular_velocity;
     4f6:	d3 82       	std	Z+3, r13	; 0x03
     4f8:	c2 82       	std	Z+2, r12	; 0x02
    //gp_i2c_telemetry->linear_velocity = (int16_t)new_linear_velocity;
    //gp_i2c_telemetry->angular_velocity = (int16_t)new_angular_velocity;
}
     4fa:	df 91       	pop	r29
     4fc:	cf 91       	pop	r28
     4fe:	1f 91       	pop	r17
     500:	0f 91       	pop	r16
     502:	ff 90       	pop	r15
     504:	ef 90       	pop	r14
     506:	df 90       	pop	r13
     508:	cf 90       	pop	r12
     50a:	bf 90       	pop	r11
     50c:	af 90       	pop	r10
     50e:	9f 90       	pop	r9
     510:	8f 90       	pop	r8
     512:	7f 90       	pop	r7
     514:	6f 90       	pop	r6
     516:	5f 90       	pop	r5
     518:	4f 90       	pop	r4
     51a:	3f 90       	pop	r3
     51c:	2f 90       	pop	r2
     51e:	08 95       	ret

00000520 <Motion_Control_Stop>:
    Motion_Control_Set_Velocity( 0, 0 );
}

void  Motion_Control_Stop( void )
{
    Motion_Control_Set_Velocity( 0, 0 );
     520:	80 e0       	ldi	r24, 0x00	; 0
     522:	90 e0       	ldi	r25, 0x00	; 0
     524:	60 e0       	ldi	r22, 0x00	; 0
     526:	70 e0       	ldi	r23, 0x00	; 0
     528:	0e 94 da 01 	call	0x3b4	; 0x3b4 <Motion_Control_Set_Velocity>
}
     52c:	08 95       	ret

0000052e <Motion_Control_Set_Update_Velocity>:

void    Motion_Control_Set_Update_Velocity( int16_t linear_velocity,    // s7.8 ticks/update
                                            int16_t angular_velocity,   // s7.8 ticks/update
                                            volatile Motion_State_t *p_state )
{
     52e:	fa 01       	movw	r30, r20
    p_state->linear_velocity_setpoint = linear_velocity;
     530:	95 83       	std	Z+5, r25	; 0x05
     532:	84 83       	std	Z+4, r24	; 0x04
    p_state->angular_velocity_setpoint = angular_velocity;
     534:	71 83       	std	Z+1, r23	; 0x01
     536:	60 83       	st	Z, r22
}
     538:	08 95       	ret

0000053a <Motion_Control_Add_To_Encoder>:
    return Motion_Control_Run_PID( new_encoder_ticks, p_state );
}

void Motion_Control_Add_To_Encoder( int8_t new_encoder_ticks,  // s7.0 ticks 
                                    volatile Motion_State_t *p_state )
{
     53a:	fb 01       	movw	r30, r22
    p_state->encoder += new_encoder_ticks;
     53c:	24 85       	ldd	r18, Z+12	; 0x0c
     53e:	35 85       	ldd	r19, Z+13	; 0x0d
     540:	46 85       	ldd	r20, Z+14	; 0x0e
     542:	57 85       	ldd	r21, Z+15	; 0x0f
     544:	99 27       	eor	r25, r25
     546:	87 fd       	sbrc	r24, 7
     548:	90 95       	com	r25
     54a:	a9 2f       	mov	r26, r25
     54c:	b9 2f       	mov	r27, r25
     54e:	82 0f       	add	r24, r18
     550:	93 1f       	adc	r25, r19
     552:	a4 1f       	adc	r26, r20
     554:	b5 1f       	adc	r27, r21
     556:	84 87       	std	Z+12, r24	; 0x0c
     558:	95 87       	std	Z+13, r25	; 0x0d
     55a:	a6 87       	std	Z+14, r26	; 0x0e
     55c:	b7 87       	std	Z+15, r27	; 0x0f
}
     55e:	08 95       	ret

00000560 <Motion_Control_Add_To_Position>:
 *  Do this with interrupts off since the motor control
 *  task might be reading the value. -where? SJL
 *
 */
void Motion_Control_Add_To_Position( int16_t num_ticks, volatile Motion_State_t *p_motion )
{
     560:	af 92       	push	r10
     562:	bf 92       	push	r11
     564:	cf 92       	push	r12
     566:	df 92       	push	r13
     568:	ef 92       	push	r14
     56a:	ff 92       	push	r15
     56c:	0f 93       	push	r16
     56e:	1f 93       	push	r17
     570:	df 93       	push	r29
     572:	cf 93       	push	r28
     574:	00 d0       	rcall	.+0      	; 0x576 <Motion_Control_Add_To_Position+0x16>
     576:	cd b7       	in	r28, 0x3d	; 61
     578:	de b7       	in	r29, 0x3e	; 62
     57a:	5c 01       	movw	r10, r24
     57c:	6b 01       	movw	r12, r22
    int16_t new_pid_setpoint;

    new_pid_setpoint = (int16_t)( ( p_motion->encoder_setpoint / 256) - p_motion->encoder );
     57e:	fb 01       	movw	r30, r22
     580:	60 85       	ldd	r22, Z+8	; 0x08
     582:	71 85       	ldd	r23, Z+9	; 0x09
     584:	82 85       	ldd	r24, Z+10	; 0x0a
     586:	93 85       	ldd	r25, Z+11	; 0x0b
     588:	e4 84       	ldd	r14, Z+12	; 0x0c
     58a:	f5 84       	ldd	r15, Z+13	; 0x0d
     58c:	06 85       	ldd	r16, Z+14	; 0x0e
     58e:	17 85       	ldd	r17, Z+15	; 0x0f
     590:	20 e0       	ldi	r18, 0x00	; 0
     592:	31 e0       	ldi	r19, 0x01	; 1
     594:	40 e0       	ldi	r20, 0x00	; 0
     596:	50 e0       	ldi	r21, 0x00	; 0
     598:	0e 94 58 08 	call	0x10b0	; 0x10b0 <__divmodsi4>
     59c:	2e 19       	sub	r18, r14
     59e:	3f 09       	sbc	r19, r15
     5a0:	3a 83       	std	Y+2, r19	; 0x02
     5a2:	29 83       	std	Y+1, r18	; 0x01

    // Prevent run-away setpoints! If there is already more positive error, than the velocity
    // you are trying to acheive, don't add more.
    if ( (num_ticks > 0) && (( num_ticks / 256 ) > new_pid_setpoint) )
     5a4:	1a 14       	cp	r1, r10
     5a6:	1b 04       	cpc	r1, r11
     5a8:	44 f4       	brge	.+16     	; 0x5ba <Motion_Control_Add_To_Position+0x5a>
     5aa:	8b 2d       	mov	r24, r11
     5ac:	99 27       	eor	r25, r25
     5ae:	87 fd       	sbrc	r24, 7
     5b0:	9a 95       	dec	r25
     5b2:	28 17       	cp	r18, r24
     5b4:	39 07       	cpc	r19, r25
     5b6:	84 f5       	brge	.+96     	; 0x618 <Motion_Control_Add_To_Position+0xb8>
     5b8:	0b c0       	rjmp	.+22     	; 0x5d0 <Motion_Control_Add_To_Position+0x70>
        p_motion->encoder_setpoint += num_ticks; // Setpoint and num_ticks are sX.8 numbers
        new_pid_setpoint = (int16_t)( ( p_motion->encoder_setpoint / 256) - p_motion->encoder );
    }    
    // Similarly if there is already more error (going backward), than the velocity
    // you are trying to acheive, don't add more.
    else if ( (num_ticks < 0) && (( num_ticks / 256 ) < new_pid_setpoint) )
     5ba:	a1 14       	cp	r10, r1
     5bc:	b1 04       	cpc	r11, r1
     5be:	61 f1       	breq	.+88     	; 0x618 <Motion_Control_Add_To_Position+0xb8>
     5c0:	c5 01       	movw	r24, r10
     5c2:	60 e0       	ldi	r22, 0x00	; 0
     5c4:	71 e0       	ldi	r23, 0x01	; 1
     5c6:	0e 94 45 08 	call	0x108a	; 0x108a <__divmodhi4>
     5ca:	62 17       	cp	r22, r18
     5cc:	73 07       	cpc	r23, r19
     5ce:	24 f5       	brge	.+72     	; 0x618 <Motion_Control_Add_To_Position+0xb8>
    { 
        p_motion->encoder_setpoint += num_ticks; // Setpoint and num_ticks are sX.8 numbers
     5d0:	f6 01       	movw	r30, r12
     5d2:	20 85       	ldd	r18, Z+8	; 0x08
     5d4:	31 85       	ldd	r19, Z+9	; 0x09
     5d6:	42 85       	ldd	r20, Z+10	; 0x0a
     5d8:	53 85       	ldd	r21, Z+11	; 0x0b
     5da:	c5 01       	movw	r24, r10
     5dc:	aa 27       	eor	r26, r26
     5de:	97 fd       	sbrc	r25, 7
     5e0:	a0 95       	com	r26
     5e2:	ba 2f       	mov	r27, r26
     5e4:	82 0f       	add	r24, r18
     5e6:	93 1f       	adc	r25, r19
     5e8:	a4 1f       	adc	r26, r20
     5ea:	b5 1f       	adc	r27, r21
     5ec:	80 87       	std	Z+8, r24	; 0x08
     5ee:	91 87       	std	Z+9, r25	; 0x09
     5f0:	a2 87       	std	Z+10, r26	; 0x0a
     5f2:	b3 87       	std	Z+11, r27	; 0x0b
        new_pid_setpoint = (int16_t)( ( p_motion->encoder_setpoint / 256) - p_motion->encoder );
     5f4:	60 85       	ldd	r22, Z+8	; 0x08
     5f6:	71 85       	ldd	r23, Z+9	; 0x09
     5f8:	82 85       	ldd	r24, Z+10	; 0x0a
     5fa:	93 85       	ldd	r25, Z+11	; 0x0b
     5fc:	e4 84       	ldd	r14, Z+12	; 0x0c
     5fe:	f5 84       	ldd	r15, Z+13	; 0x0d
     600:	06 85       	ldd	r16, Z+14	; 0x0e
     602:	17 85       	ldd	r17, Z+15	; 0x0f
     604:	20 e0       	ldi	r18, 0x00	; 0
     606:	31 e0       	ldi	r19, 0x01	; 1
     608:	40 e0       	ldi	r20, 0x00	; 0
     60a:	50 e0       	ldi	r21, 0x00	; 0
     60c:	0e 94 58 08 	call	0x10b0	; 0x10b0 <__divmodsi4>
     610:	2e 19       	sub	r18, r14
     612:	3f 09       	sbc	r19, r15
     614:	3a 83       	std	Y+2, r19	; 0x02
     616:	29 83       	std	Y+1, r18	; 0x01
    }    
    
    // HACK!!! new_pid_setpoint should be around 5, so 100 should be Way safe.
    // The pid setpoint was routinely getting set to 170-220...
    // With this change I have seen no anomalous behavior.
    if ( CLAMP_VALUE_NOT_CLAMPED == Clamp_Abs_Value(&new_pid_setpoint, 100 ) )
     618:	ce 01       	movw	r24, r28
     61a:	01 96       	adiw	r24, 0x01	; 1
     61c:	64 e6       	ldi	r22, 0x64	; 100
     61e:	70 e0       	ldi	r23, 0x00	; 0
     620:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <Clamp_Abs_Value>
     624:	88 23       	and	r24, r24
     626:	29 f4       	brne	.+10     	; 0x632 <Motion_Control_Add_To_Position+0xd2>
    {
        p_motion->pid.setpoint = new_pid_setpoint;
     628:	89 81       	ldd	r24, Y+1	; 0x01
     62a:	9a 81       	ldd	r25, Y+2	; 0x02
     62c:	f6 01       	movw	r30, r12
     62e:	93 8b       	std	Z+19, r25	; 0x13
     630:	82 8b       	std	Z+18, r24	; 0x12
    }
}
     632:	0f 90       	pop	r0
     634:	0f 90       	pop	r0
     636:	cf 91       	pop	r28
     638:	df 91       	pop	r29
     63a:	1f 91       	pop	r17
     63c:	0f 91       	pop	r16
     63e:	ff 90       	pop	r15
     640:	ef 90       	pop	r14
     642:	df 90       	pop	r13
     644:	cf 90       	pop	r12
     646:	bf 90       	pop	r11
     648:	af 90       	pop	r10
     64a:	08 95       	ret

0000064c <Motion_Control_Compute_Target_Position>:

void Motion_Control_Compute_Target_Position( volatile Motion_State_t *p_motion )
{
     64c:	fc 01       	movw	r30, r24
    int16_t new_velocity;

    // Linear Velocity
    if ( p_motion->linear_velocity < p_motion->linear_velocity_setpoint )
     64e:	26 81       	ldd	r18, Z+6	; 0x06
     650:	37 81       	ldd	r19, Z+7	; 0x07
     652:	84 81       	ldd	r24, Z+4	; 0x04
     654:	95 81       	ldd	r25, Z+5	; 0x05
     656:	28 17       	cp	r18, r24
     658:	39 07       	cpc	r19, r25
     65a:	94 f4       	brge	.+36     	; 0x680 <Motion_Control_Compute_Target_Position+0x34>
    {
        p_motion->linear_velocity += m_linear_acceleration;
     65c:	86 81       	ldd	r24, Z+6	; 0x06
     65e:	97 81       	ldd	r25, Z+7	; 0x07
     660:	20 91 a1 01 	lds	r18, 0x01A1
     664:	30 91 a2 01 	lds	r19, 0x01A2
     668:	82 0f       	add	r24, r18
     66a:	93 1f       	adc	r25, r19
     66c:	97 83       	std	Z+7, r25	; 0x07
     66e:	86 83       	std	Z+6, r24	; 0x06

        if ( p_motion->linear_velocity > p_motion->linear_velocity_setpoint )
     670:	26 81       	ldd	r18, Z+6	; 0x06
     672:	37 81       	ldd	r19, Z+7	; 0x07
     674:	84 81       	ldd	r24, Z+4	; 0x04
     676:	95 81       	ldd	r25, Z+5	; 0x05
     678:	82 17       	cp	r24, r18
     67a:	93 07       	cpc	r25, r19
     67c:	b4 f4       	brge	.+44     	; 0x6aa <Motion_Control_Compute_Target_Position+0x5e>
     67e:	11 c0       	rjmp	.+34     	; 0x6a2 <Motion_Control_Compute_Target_Position+0x56>
            p_motion->linear_velocity = p_motion->linear_velocity_setpoint;
        }
    }
    else
    {
        p_motion->linear_velocity -= m_linear_acceleration;
     680:	86 81       	ldd	r24, Z+6	; 0x06
     682:	97 81       	ldd	r25, Z+7	; 0x07
     684:	20 91 a1 01 	lds	r18, 0x01A1
     688:	30 91 a2 01 	lds	r19, 0x01A2
     68c:	82 1b       	sub	r24, r18
     68e:	93 0b       	sbc	r25, r19
     690:	97 83       	std	Z+7, r25	; 0x07
     692:	86 83       	std	Z+6, r24	; 0x06

        if ( p_motion->linear_velocity < p_motion->linear_velocity_setpoint )
     694:	26 81       	ldd	r18, Z+6	; 0x06
     696:	37 81       	ldd	r19, Z+7	; 0x07
     698:	84 81       	ldd	r24, Z+4	; 0x04
     69a:	95 81       	ldd	r25, Z+5	; 0x05
     69c:	28 17       	cp	r18, r24
     69e:	39 07       	cpc	r19, r25
     6a0:	24 f4       	brge	.+8      	; 0x6aa <Motion_Control_Compute_Target_Position+0x5e>
        {
            p_motion->linear_velocity = p_motion->linear_velocity_setpoint;
     6a2:	84 81       	ldd	r24, Z+4	; 0x04
     6a4:	95 81       	ldd	r25, Z+5	; 0x05
     6a6:	97 83       	std	Z+7, r25	; 0x07
     6a8:	86 83       	std	Z+6, r24	; 0x06
        }
    }

    // Angular Velocity
    if ( p_motion->angular_velocity < p_motion->angular_velocity_setpoint )
     6aa:	22 81       	ldd	r18, Z+2	; 0x02
     6ac:	33 81       	ldd	r19, Z+3	; 0x03
     6ae:	80 81       	ld	r24, Z
     6b0:	91 81       	ldd	r25, Z+1	; 0x01
     6b2:	28 17       	cp	r18, r24
     6b4:	39 07       	cpc	r19, r25
     6b6:	94 f4       	brge	.+36     	; 0x6dc <Motion_Control_Compute_Target_Position+0x90>
    {
        p_motion->angular_velocity += m_angular_acceleration; 
     6b8:	82 81       	ldd	r24, Z+2	; 0x02
     6ba:	93 81       	ldd	r25, Z+3	; 0x03
     6bc:	20 91 a3 01 	lds	r18, 0x01A3
     6c0:	30 91 a4 01 	lds	r19, 0x01A4
     6c4:	82 0f       	add	r24, r18
     6c6:	93 1f       	adc	r25, r19
     6c8:	93 83       	std	Z+3, r25	; 0x03
     6ca:	82 83       	std	Z+2, r24	; 0x02

        if ( p_motion->angular_velocity > p_motion->angular_velocity_setpoint )
     6cc:	22 81       	ldd	r18, Z+2	; 0x02
     6ce:	33 81       	ldd	r19, Z+3	; 0x03
     6d0:	80 81       	ld	r24, Z
     6d2:	91 81       	ldd	r25, Z+1	; 0x01
     6d4:	82 17       	cp	r24, r18
     6d6:	93 07       	cpc	r25, r19
     6d8:	b4 f4       	brge	.+44     	; 0x706 <Motion_Control_Compute_Target_Position+0xba>
     6da:	11 c0       	rjmp	.+34     	; 0x6fe <Motion_Control_Compute_Target_Position+0xb2>
            p_motion->angular_velocity = p_motion->angular_velocity_setpoint;
        }
    }
    else
    {
        p_motion->angular_velocity -= m_angular_acceleration;
     6dc:	82 81       	ldd	r24, Z+2	; 0x02
     6de:	93 81       	ldd	r25, Z+3	; 0x03
     6e0:	20 91 a3 01 	lds	r18, 0x01A3
     6e4:	30 91 a4 01 	lds	r19, 0x01A4
     6e8:	82 1b       	sub	r24, r18
     6ea:	93 0b       	sbc	r25, r19
     6ec:	93 83       	std	Z+3, r25	; 0x03
     6ee:	82 83       	std	Z+2, r24	; 0x02

        if ( p_motion->angular_velocity < p_motion->angular_velocity_setpoint )
     6f0:	22 81       	ldd	r18, Z+2	; 0x02
     6f2:	33 81       	ldd	r19, Z+3	; 0x03
     6f4:	80 81       	ld	r24, Z
     6f6:	91 81       	ldd	r25, Z+1	; 0x01
     6f8:	28 17       	cp	r18, r24
     6fa:	39 07       	cpc	r19, r25
     6fc:	24 f4       	brge	.+8      	; 0x706 <Motion_Control_Compute_Target_Position+0xba>
        {
            p_motion->angular_velocity = p_motion->angular_velocity_setpoint;
     6fe:	80 81       	ld	r24, Z
     700:	91 81       	ldd	r25, Z+1	; 0x01
     702:	93 83       	std	Z+3, r25	; 0x03
     704:	82 83       	std	Z+2, r24	; 0x02
        }
    }

    new_velocity = p_motion->linear_velocity + p_motion->angular_velocity;
     706:	26 81       	ldd	r18, Z+6	; 0x06
     708:	37 81       	ldd	r19, Z+7	; 0x07
     70a:	82 81       	ldd	r24, Z+2	; 0x02
     70c:	93 81       	ldd	r25, Z+3	; 0x03

    Motion_Control_Add_To_Position( new_velocity, p_motion );
     70e:	82 0f       	add	r24, r18
     710:	93 1f       	adc	r25, r19
     712:	bf 01       	movw	r22, r30
     714:	0e 94 b0 02 	call	0x560	; 0x560 <Motion_Control_Add_To_Position>
}
     718:	08 95       	ret

0000071a <Motion_Control_Run_PID>:

/** This function runs a PID correction.
 */
int16_t Motion_Control_Run_PID( int8_t new_encoder_ticks,  // s7.0 ticks 
                                volatile Motion_State_t *p_state )
{
     71a:	cf 93       	push	r28
     71c:	df 93       	push	r29
     71e:	eb 01       	movw	r28, r22
  int16_t power;
  int16_t error_squared;

  power = Pid_Compute_Correction( new_encoder_ticks, &( p_state->pid ) );
     720:	6e 5e       	subi	r22, 0xEE	; 238
     722:	7f 4f       	sbci	r23, 0xFF	; 255
     724:	99 27       	eor	r25, r25
     726:	87 fd       	sbrc	r24, 7
     728:	90 95       	com	r25
     72a:	0e 94 a9 07 	call	0xf52	; 0xf52 <Pid_Compute_Correction>
     72e:	bc 01       	movw	r22, r24

  if  ( ( p_state->linear_velocity == 0 ) &&
     730:	8e 81       	ldd	r24, Y+6	; 0x06
     732:	9f 81       	ldd	r25, Y+7	; 0x07
     734:	89 2b       	or	r24, r25
     736:	e9 f4       	brne	.+58     	; 0x772 <Motion_Control_Run_PID+0x58>
     738:	8a 81       	ldd	r24, Y+2	; 0x02
     73a:	9b 81       	ldd	r25, Y+3	; 0x03
     73c:	89 2b       	or	r24, r25
     73e:	c9 f4       	brne	.+50     	; 0x772 <Motion_Control_Run_PID+0x58>
     740:	2c 89       	ldd	r18, Y+20	; 0x14
     742:	3d 89       	ldd	r19, Y+21	; 0x15
     744:	8c 89       	ldd	r24, Y+20	; 0x14
     746:	9d 89       	ldd	r25, Y+21	; 0x15
     748:	82 9f       	mul	r24, r18
     74a:	a0 01       	movw	r20, r0
     74c:	83 9f       	mul	r24, r19
     74e:	50 0d       	add	r21, r0
     750:	92 9f       	mul	r25, r18
     752:	50 0d       	add	r21, r0
     754:	11 24       	eor	r1, r1
     756:	45 30       	cpi	r20, 0x05	; 5
     758:	51 05       	cpc	r21, r1
     75a:	5c f4       	brge	.+22     	; 0x772 <Motion_Control_Run_PID+0x58>
        ( p_state->angular_velocity == 0 ) &&
        (( error_squared = p_state->pid.error * p_state->pid.error ) < 5) ) // 10 should mean within 3 encoder ticks
  {
    power = (power * error_squared) / 8;
     75c:	64 9f       	mul	r22, r20
     75e:	c0 01       	movw	r24, r0
     760:	65 9f       	mul	r22, r21
     762:	90 0d       	add	r25, r0
     764:	74 9f       	mul	r23, r20
     766:	90 0d       	add	r25, r0
     768:	11 24       	eor	r1, r1
     76a:	68 e0       	ldi	r22, 0x08	; 8
     76c:	70 e0       	ldi	r23, 0x00	; 0
     76e:	0e 94 45 08 	call	0x108a	; 0x108a <__divmodhi4>
  }

  p_state->power_out = power;
     772:	79 8b       	std	Y+17, r23	; 0x11
     774:	68 8b       	std	Y+16, r22	; 0x10

  return power;
}
     776:	cb 01       	movw	r24, r22
     778:	df 91       	pop	r29
     77a:	cf 91       	pop	r28
     77c:	08 95       	ret

0000077e <Motion_Control_Compute_Power>:

/** This function computes an entire update cycle.
 */
int16_t Motion_Control_Compute_Power(   int8_t new_encoder_ticks,     // s15.0 ticks
                                        volatile Motion_State_t *p_state )
{
     77e:	ff 92       	push	r15
     780:	0f 93       	push	r16
     782:	1f 93       	push	r17
     784:	f8 2e       	mov	r15, r24
     786:	8b 01       	movw	r16, r22
}

void Motion_Control_Add_To_Encoder( int8_t new_encoder_ticks,  // s7.0 ticks 
                                    volatile Motion_State_t *p_state )
{
    p_state->encoder += new_encoder_ticks;
     788:	fb 01       	movw	r30, r22
     78a:	24 85       	ldd	r18, Z+12	; 0x0c
     78c:	35 85       	ldd	r19, Z+13	; 0x0d
     78e:	46 85       	ldd	r20, Z+14	; 0x0e
     790:	57 85       	ldd	r21, Z+15	; 0x0f
     792:	99 27       	eor	r25, r25
     794:	87 fd       	sbrc	r24, 7
     796:	90 95       	com	r25
     798:	a9 2f       	mov	r26, r25
     79a:	b9 2f       	mov	r27, r25
     79c:	82 0f       	add	r24, r18
     79e:	93 1f       	adc	r25, r19
     7a0:	a4 1f       	adc	r26, r20
     7a2:	b5 1f       	adc	r27, r21
     7a4:	84 87       	std	Z+12, r24	; 0x0c
     7a6:	95 87       	std	Z+13, r25	; 0x0d
     7a8:	a6 87       	std	Z+14, r26	; 0x0e
     7aa:	b7 87       	std	Z+15, r27	; 0x0f
int16_t Motion_Control_Compute_Power(   int8_t new_encoder_ticks,     // s15.0 ticks
                                        volatile Motion_State_t *p_state )
{
    Motion_Control_Add_To_Encoder( new_encoder_ticks, p_state );

    Motion_Control_Compute_Target_Position( p_state );
     7ac:	cb 01       	movw	r24, r22
     7ae:	0e 94 26 03 	call	0x64c	; 0x64c <Motion_Control_Compute_Target_Position>

    return Motion_Control_Run_PID( new_encoder_ticks, p_state );
     7b2:	8f 2d       	mov	r24, r15
     7b4:	b8 01       	movw	r22, r16
     7b6:	0e 94 8d 03 	call	0x71a	; 0x71a <Motion_Control_Run_PID>
}
     7ba:	1f 91       	pop	r17
     7bc:	0f 91       	pop	r16
     7be:	ff 90       	pop	r15
     7c0:	08 95       	ret

000007c2 <Motion_Control_EStop>:
    //gp_i2c_telemetry->angular_velocity = (int16_t)new_angular_velocity;
}

void  Motion_Control_EStop( void )
{
    g_estop = 1;
     7c2:	81 e0       	ldi	r24, 0x01	; 1
     7c4:	80 93 5e 01 	sts	0x015E, r24

    Motors_Set_Direction( MOTORS_L_INDEX, MOTORS_BRAKE );
     7c8:	80 e0       	ldi	r24, 0x00	; 0
     7ca:	60 e0       	ldi	r22, 0x00	; 0
     7cc:	0e 94 a0 04 	call	0x940	; 0x940 <Motors_Set_Direction>
    Motors_Set_Direction( MOTORS_R_INDEX, MOTORS_BRAKE );
     7d0:	81 e0       	ldi	r24, 0x01	; 1
     7d2:	60 e0       	ldi	r22, 0x00	; 0
     7d4:	0e 94 a0 04 	call	0x940	; 0x940 <Motors_Set_Direction>

    Motion_Control_Set_Velocity( 0, 0 );
     7d8:	80 e0       	ldi	r24, 0x00	; 0
     7da:	90 e0       	ldi	r25, 0x00	; 0
     7dc:	60 e0       	ldi	r22, 0x00	; 0
     7de:	70 e0       	ldi	r23, 0x00	; 0
     7e0:	0e 94 da 01 	call	0x3b4	; 0x3b4 <Motion_Control_Set_Velocity>
}
     7e4:	08 95       	ret

000007e6 <Motion_Control_Init>:

/* FUNCTIONS */

void Motion_Control_Init(   void )
{
    Motion_Control_Init_Acceleration();
     7e6:	0e 94 a7 01 	call	0x34e	; 0x34e <Motion_Control_Init_Acceleration>
    Motion_Control_Init_State( &g_left_wheel_motion );
     7ea:	85 ea       	ldi	r24, 0xA5	; 165
     7ec:	91 e0       	ldi	r25, 0x01	; 1
     7ee:	0e 94 ae 01 	call	0x35c	; 0x35c <Motion_Control_Init_State>
    Motion_Control_Init_State( &g_right_wheel_motion );
     7f2:	8b e7       	ldi	r24, 0x7B	; 123
     7f4:	91 e0       	ldi	r25, 0x01	; 1
     7f6:	0e 94 ae 01 	call	0x35c	; 0x35c <Motion_Control_Init_State>
    Motion_Control_Set_Velocity( 0, 0 );
     7fa:	80 e0       	ldi	r24, 0x00	; 0
     7fc:	90 e0       	ldi	r25, 0x00	; 0
     7fe:	60 e0       	ldi	r22, 0x00	; 0
     800:	70 e0       	ldi	r23, 0x00	; 0
     802:	0e 94 da 01 	call	0x3b4	; 0x3b4 <Motion_Control_Set_Velocity>

    m_max_velocity = MOTION_CONTROL_DEFAULT_MAX_VELOCITY;
     806:	80 e8       	ldi	r24, 0x80	; 128
     808:	90 e0       	ldi	r25, 0x00	; 0
     80a:	90 93 a0 01 	sts	0x01A0, r25
     80e:	80 93 9f 01 	sts	0x019F, r24
    
    Motors_Set_Direction(MOTORS_L_INDEX, MOTORS_FORWARD);
     812:	80 e0       	ldi	r24, 0x00	; 0
     814:	62 e0       	ldi	r22, 0x02	; 2
     816:	0e 94 a0 04 	call	0x940	; 0x940 <Motors_Set_Direction>
    Motors_Set_Direction(MOTORS_R_INDEX, MOTORS_FORWARD);
     81a:	81 e0       	ldi	r24, 0x01	; 1
     81c:	62 e0       	ldi	r22, 0x02	; 2
     81e:	0e 94 a0 04 	call	0x940	; 0x940 <Motors_Set_Direction>
}
     822:	08 95       	ret

00000824 <Motion_Control_Run_Step>:

/** This function runs a complete motion step. This includes reading the encoder 
 *  values and commanding the motors.
 */
void Motion_Control_Run_Step(   void )
{
     824:	cf 92       	push	r12
     826:	df 92       	push	r13
     828:	ef 92       	push	r14
     82a:	ff 92       	push	r15
     82c:	0f 93       	push	r16
     82e:	1f 93       	push	r17
     830:	cf 93       	push	r28
     832:	df 93       	push	r29
    int16_t right_power;

    uint16_t measurement_time;

    // Get new encoder counts
    DISABLE_INTERRUPTS();
     834:	f8 94       	cli
    delta_left = g_shaft_encoders_left_count;
     836:	80 91 63 01 	lds	r24, 0x0163
     83a:	90 91 64 01 	lds	r25, 0x0164
    delta_right = g_shaft_encoders_right_count;
     83e:	00 91 65 01 	lds	r16, 0x0165
     842:	10 91 66 01 	lds	r17, 0x0166
    stasis_total += g_shaft_encoders_stasis_count;
     846:	40 91 67 01 	lds	r20, 0x0167
     84a:	50 91 68 01 	lds	r21, 0x0168
     84e:	20 91 5f 01 	lds	r18, 0x015F
     852:	30 91 60 01 	lds	r19, 0x0160
     856:	24 0f       	add	r18, r20
     858:	35 1f       	adc	r19, r21
     85a:	30 93 60 01 	sts	0x0160, r19
     85e:	20 93 5f 01 	sts	0x015F, r18

    g_shaft_encoders_left_count = 0;
     862:	10 92 64 01 	sts	0x0164, r1
     866:	10 92 63 01 	sts	0x0163, r1
    g_shaft_encoders_right_count = 0;
     86a:	10 92 66 01 	sts	0x0166, r1
     86e:	10 92 65 01 	sts	0x0165, r1
    g_shaft_encoders_stasis_count = 0;
     872:	10 92 68 01 	sts	0x0168, r1
     876:	10 92 67 01 	sts	0x0167, r1

    measurement_time = (uint16_t)g_system_clock;
     87a:	c0 90 54 01 	lds	r12, 0x0154
     87e:	d0 90 55 01 	lds	r13, 0x0155
    ENABLE_INTERRUPTS();
     882:	78 94       	sei

    // Set motor power
    left_power =    Motion_Control_Compute_Power(   delta_left,   p_l_wheel );
     884:	65 ea       	ldi	r22, 0xA5	; 165
     886:	71 e0       	ldi	r23, 0x01	; 1
     888:	0e 94 bf 03 	call	0x77e	; 0x77e <Motion_Control_Compute_Power>
     88c:	7c 01       	movw	r14, r24
    right_power =   Motion_Control_Compute_Power(   delta_right,  p_r_wheel );
     88e:	80 2f       	mov	r24, r16
     890:	6b e7       	ldi	r22, 0x7B	; 123
     892:	71 e0       	ldi	r23, 0x01	; 1
     894:	0e 94 bf 03 	call	0x77e	; 0x77e <Motion_Control_Compute_Power>
     898:	ec 01       	movw	r28, r24

    if (!g_estop)
     89a:	80 91 5e 01 	lds	r24, 0x015E
     89e:	88 23       	and	r24, r24
     8a0:	01 f5       	brne	.+64     	; 0x8e2 <Motion_Control_Run_Step+0xbe>
    {
        if (left_power < 0)
     8a2:	f7 fe       	sbrs	r15, 7
     8a4:	06 c0       	rjmp	.+12     	; 0x8b2 <Motion_Control_Run_Step+0x8e>
        {
            left_power *= -1;
     8a6:	f0 94       	com	r15
     8a8:	e1 94       	neg	r14
     8aa:	f1 08       	sbc	r15, r1
     8ac:	f3 94       	inc	r15
            Motors_Set_Direction(   MOTORS_L_INDEX, MOTORS_REVERSE );
     8ae:	63 e0       	ldi	r22, 0x03	; 3
     8b0:	02 c0       	rjmp	.+4      	; 0x8b6 <Motion_Control_Run_Step+0x92>
        }
        else
        {
            Motors_Set_Direction(   MOTORS_L_INDEX, MOTORS_FORWARD);
     8b2:	80 e0       	ldi	r24, 0x00	; 0
     8b4:	62 e0       	ldi	r22, 0x02	; 2
     8b6:	0e 94 a0 04 	call	0x940	; 0x940 <Motors_Set_Direction>
        }
     
        if (right_power < 0)
     8ba:	d7 ff       	sbrs	r29, 7
     8bc:	06 c0       	rjmp	.+12     	; 0x8ca <Motion_Control_Run_Step+0xa6>
        {
            right_power *= -1;
     8be:	d0 95       	com	r29
     8c0:	c1 95       	neg	r28
     8c2:	df 4f       	sbci	r29, 0xFF	; 255
            Motors_Set_Direction(   MOTORS_R_INDEX, MOTORS_REVERSE);
     8c4:	81 e0       	ldi	r24, 0x01	; 1
     8c6:	63 e0       	ldi	r22, 0x03	; 3
     8c8:	02 c0       	rjmp	.+4      	; 0x8ce <Motion_Control_Run_Step+0xaa>
        }
        else
        {
            Motors_Set_Direction(   MOTORS_R_INDEX, MOTORS_FORWARD);
     8ca:	81 e0       	ldi	r24, 0x01	; 1
     8cc:	62 e0       	ldi	r22, 0x02	; 2
     8ce:	0e 94 a0 04 	call	0x940	; 0x940 <Motors_Set_Direction>
        }

        Motors_Set_Power(   MOTORS_L_INDEX, left_power & 0xFF);
     8d2:	80 e0       	ldi	r24, 0x00	; 0
     8d4:	6e 2d       	mov	r22, r14
     8d6:	0e 94 18 05 	call	0xa30	; 0xa30 <Motors_Set_Power>
        Motors_Set_Power(   MOTORS_R_INDEX, right_power & 0xFF);
     8da:	81 e0       	ldi	r24, 0x01	; 1
     8dc:	6c 2f       	mov	r22, r28
     8de:	0e 94 18 05 	call	0xa30	; 0xa30 <Motors_Set_Power>
    }

    // Update telemetry registers
    DISABLE_INTERRUPTS();
     8e2:	f8 94       	cli

    gp_telemetry_write->left_encoder = (int16_t)(p_l_wheel->encoder);
     8e4:	e0 91 75 01 	lds	r30, 0x0175
     8e8:	f0 91 76 01 	lds	r31, 0x0176
     8ec:	80 91 b1 01 	lds	r24, 0x01B1
     8f0:	90 91 b2 01 	lds	r25, 0x01B2
     8f4:	a0 91 b3 01 	lds	r26, 0x01B3
     8f8:	b0 91 b4 01 	lds	r27, 0x01B4
     8fc:	95 83       	std	Z+5, r25	; 0x05
     8fe:	84 83       	std	Z+4, r24	; 0x04
    gp_telemetry_write->right_encoder = (int16_t)(p_r_wheel->encoder);
     900:	80 91 87 01 	lds	r24, 0x0187
     904:	90 91 88 01 	lds	r25, 0x0188
     908:	a0 91 89 01 	lds	r26, 0x0189
     90c:	b0 91 8a 01 	lds	r27, 0x018A
     910:	97 83       	std	Z+7, r25	; 0x07
     912:	86 83       	std	Z+6, r24	; 0x06
    gp_telemetry_write->stasis_encoder = stasis_total;
     914:	80 91 5f 01 	lds	r24, 0x015F
     918:	90 91 60 01 	lds	r25, 0x0160
     91c:	91 87       	std	Z+9, r25	; 0x09
     91e:	80 87       	std	Z+8, r24	; 0x08
    gp_telemetry_write->measurement_time = measurement_time;
     920:	d3 86       	std	Z+11, r13	; 0x0b
     922:	c2 86       	std	Z+10, r12	; 0x0a

    ENABLE_INTERRUPTS();
     924:	78 94       	sei
} 
     926:	df 91       	pop	r29
     928:	cf 91       	pop	r28
     92a:	1f 91       	pop	r17
     92c:	0f 91       	pop	r16
     92e:	ff 90       	pop	r15
     930:	ef 90       	pop	r14
     932:	df 90       	pop	r13
     934:	cf 90       	pop	r12
     936:	08 95       	ret

00000938 <Motors_Enable>:
    return ;
}

void Motors_Enable()
{
    MOTORS_ENABLE();
     938:	40 9a       	sbi	0x08, 0	; 8
}
     93a:	08 95       	ret

0000093c <Motors_Disable>:

void Motors_Disable()
{
    MOTORS_DISABLE();
     93c:	40 98       	cbi	0x08, 0	; 8
}
     93e:	08 95       	ret

00000940 <Motors_Set_Direction>:
 */
void Motors_Set_Direction( uint8_t motor_index, uint8_t motor_direction )
{
    static uint8_t last_direction[2];

    if ((MOTORS_L_INDEX == motor_index) && (last_direction[MOTORS_L_INDEX] != motor_direction))
     940:	88 23       	and	r24, r24
     942:	49 f5       	brne	.+82     	; 0x996 <Motors_Set_Direction+0x56>
     944:	80 91 61 01 	lds	r24, 0x0161
     948:	86 17       	cp	r24, r22
     94a:	09 f4       	brne	.+2      	; 0x94e <Motors_Set_Direction+0xe>
     94c:	4c c0       	rjmp	.+152    	; 0x9e6 <Motors_Set_Direction+0xa6>
    {
        if ((MOTORS_BRAKE == last_direction[MOTORS_L_INDEX]) ||
     94e:	82 30       	cpi	r24, 0x02	; 2
     950:	a8 f4       	brcc	.+42     	; 0x97c <Motors_Set_Direction+0x3c>
            (MOTORS_COAST == last_direction[MOTORS_L_INDEX]))
        {
            if (MOTORS_FORWARD == motor_direction)
     952:	62 30       	cpi	r22, 0x02	; 2
     954:	19 f4       	brne	.+6      	; 0x95c <Motors_Set_Direction+0x1c>
            {
                MOTORS_L_FORWARD();
     956:	2d 98       	cbi	0x05, 5	; 5
     958:	2c 9a       	sbi	0x05, 4	; 5
     95a:	0d c0       	rjmp	.+26     	; 0x976 <Motors_Set_Direction+0x36>
            }
            else if (MOTORS_REVERSE == motor_direction)
     95c:	63 30       	cpi	r22, 0x03	; 3
     95e:	11 f4       	brne	.+4      	; 0x964 <Motors_Set_Direction+0x24>
            {
                MOTORS_L_REVERSE();
     960:	2c 98       	cbi	0x05, 4	; 5
     962:	08 c0       	rjmp	.+16     	; 0x974 <Motors_Set_Direction+0x34>
            }
            else if (MOTORS_COAST == motor_direction)
     964:	61 30       	cpi	r22, 0x01	; 1
     966:	19 f4       	brne	.+6      	; 0x96e <Motors_Set_Direction+0x2e>
            {
                MOTORS_L_COAST();
     968:	2c 98       	cbi	0x05, 4	; 5
     96a:	2d 98       	cbi	0x05, 5	; 5
     96c:	04 c0       	rjmp	.+8      	; 0x976 <Motors_Set_Direction+0x36>
            }
            else if (MOTORS_BRAKE == motor_direction)
     96e:	66 23       	and	r22, r22
     970:	11 f4       	brne	.+4      	; 0x976 <Motors_Set_Direction+0x36>
            {
                MOTORS_L_BRAKE();
     972:	2c 9a       	sbi	0x05, 4	; 5
     974:	2d 9a       	sbi	0x05, 5	; 5
            }

            last_direction[MOTORS_L_INDEX] = motor_direction;
     976:	60 93 61 01 	sts	0x0161, r22
     97a:	08 95       	ret
        }
        else
        {
            if (MOTORS_BRAKE == motor_direction)
     97c:	66 23       	and	r22, r22
     97e:	29 f4       	brne	.+10     	; 0x98a <Motors_Set_Direction+0x4a>
            {
                MOTORS_L_BRAKE();
     980:	2c 9a       	sbi	0x05, 4	; 5
     982:	2d 9a       	sbi	0x05, 5	; 5
                last_direction[MOTORS_L_INDEX] = MOTORS_BRAKE;
     984:	10 92 61 01 	sts	0x0161, r1
     988:	08 95       	ret
            }
            else
            {
                MOTORS_L_COAST();
     98a:	2c 98       	cbi	0x05, 4	; 5
     98c:	2d 98       	cbi	0x05, 5	; 5
                last_direction[MOTORS_L_INDEX] = MOTORS_COAST;
     98e:	81 e0       	ldi	r24, 0x01	; 1
     990:	80 93 61 01 	sts	0x0161, r24
     994:	08 95       	ret
            }
        }
    }
    else if ((MOTORS_R_INDEX == motor_index) && (last_direction[MOTORS_R_INDEX] != motor_direction))
     996:	81 30       	cpi	r24, 0x01	; 1
     998:	31 f5       	brne	.+76     	; 0x9e6 <Motors_Set_Direction+0xa6>
     99a:	90 91 62 01 	lds	r25, 0x0162
     99e:	96 17       	cp	r25, r22
     9a0:	11 f1       	breq	.+68     	; 0x9e6 <Motors_Set_Direction+0xa6>
    {
        if ((MOTORS_BRAKE == last_direction[MOTORS_R_INDEX]) ||
     9a2:	92 30       	cpi	r25, 0x02	; 2
     9a4:	a8 f4       	brcc	.+42     	; 0x9d0 <Motors_Set_Direction+0x90>
            (MOTORS_COAST == last_direction[MOTORS_R_INDEX]))
        {
            if (MOTORS_FORWARD == motor_direction)
     9a6:	62 30       	cpi	r22, 0x02	; 2
     9a8:	19 f4       	brne	.+6      	; 0x9b0 <Motors_Set_Direction+0x70>
            {
                MOTORS_R_FORWARD();
     9aa:	2b 98       	cbi	0x05, 3	; 5
     9ac:	28 9a       	sbi	0x05, 0	; 5
     9ae:	0d c0       	rjmp	.+26     	; 0x9ca <Motors_Set_Direction+0x8a>
            }
            else if (MOTORS_REVERSE == motor_direction)
     9b0:	63 30       	cpi	r22, 0x03	; 3
     9b2:	11 f4       	brne	.+4      	; 0x9b8 <Motors_Set_Direction+0x78>
            {
                MOTORS_R_REVERSE();
     9b4:	28 98       	cbi	0x05, 0	; 5
     9b6:	08 c0       	rjmp	.+16     	; 0x9c8 <Motors_Set_Direction+0x88>
            }
            else if (MOTORS_COAST == motor_direction)
     9b8:	61 30       	cpi	r22, 0x01	; 1
     9ba:	19 f4       	brne	.+6      	; 0x9c2 <Motors_Set_Direction+0x82>
            {
                MOTORS_R_COAST();
     9bc:	28 98       	cbi	0x05, 0	; 5
     9be:	2b 98       	cbi	0x05, 3	; 5
     9c0:	04 c0       	rjmp	.+8      	; 0x9ca <Motors_Set_Direction+0x8a>
            }
            else if (MOTORS_BRAKE == motor_direction)
     9c2:	66 23       	and	r22, r22
     9c4:	11 f4       	brne	.+4      	; 0x9ca <Motors_Set_Direction+0x8a>
            {
                MOTORS_R_BRAKE();
     9c6:	28 9a       	sbi	0x05, 0	; 5
     9c8:	2b 9a       	sbi	0x05, 3	; 5
            }

            last_direction[MOTORS_R_INDEX] = motor_direction;
     9ca:	60 93 62 01 	sts	0x0162, r22
     9ce:	08 95       	ret
        }
        else
        {
            if (MOTORS_BRAKE == motor_direction)
     9d0:	66 23       	and	r22, r22
     9d2:	29 f4       	brne	.+10     	; 0x9de <Motors_Set_Direction+0x9e>
            {
                MOTORS_R_BRAKE();
     9d4:	28 9a       	sbi	0x05, 0	; 5
     9d6:	2b 9a       	sbi	0x05, 3	; 5
                last_direction[MOTORS_R_INDEX] = MOTORS_BRAKE;
     9d8:	10 92 62 01 	sts	0x0162, r1
     9dc:	08 95       	ret
            }
            else
            {
                MOTORS_R_COAST();
     9de:	28 98       	cbi	0x05, 0	; 5
     9e0:	2b 98       	cbi	0x05, 3	; 5
                last_direction[MOTORS_R_INDEX] = MOTORS_COAST;
     9e2:	80 93 62 01 	sts	0x0162, r24
     9e6:	08 95       	ret

000009e8 <Motors_Init>:
 * ISR Timer 1 Overflow
 *-----------------------------------------------------------*/

void Motors_Init( void )
{
    OUTPUT_PIN(MOTORS_STANDBY_PORT, MOTORS_STANDBY_PIN);
     9e8:	38 9a       	sbi	0x07, 0	; 7
    OUTPUT_PIN(MOTORS_A_IN1_PORT, MOTORS_A_IN1_PIN);
     9ea:	20 9a       	sbi	0x04, 0	; 4
    OUTPUT_PIN(MOTORS_A_IN2_PORT, MOTORS_A_IN2_PIN);
     9ec:	23 9a       	sbi	0x04, 3	; 4
    OUTPUT_PIN(MOTORS_B_IN1_PORT, MOTORS_B_IN1_PIN);
     9ee:	24 9a       	sbi	0x04, 4	; 4
    OUTPUT_PIN(MOTORS_B_IN2_PORT, MOTORS_B_IN2_PIN);
     9f0:	25 9a       	sbi	0x04, 5	; 4

    OUTPUT_PIN(MOTORS_A_PWM_PORT, MOTORS_A_PWM_PIN);
     9f2:	21 9a       	sbi	0x04, 1	; 4
    OUTPUT_PIN(MOTORS_B_PWM_PORT, MOTORS_B_PWM_PIN);
     9f4:	22 9a       	sbi	0x04, 2	; 4

    // Setup Timer: Timer 1, /1 Prescale, 8-bit phase correct PWM
    TCCR1A = BIT(COM1A1) |
     9f6:	81 ea       	ldi	r24, 0xA1	; 161
     9f8:	80 93 80 00 	sts	0x0080, r24
             BIT(COM1B1) |
             BIT(WGM10);
              
    TCCR1B = BIT(CS10);
     9fc:	81 e0       	ldi	r24, 0x01	; 1
     9fe:	80 93 81 00 	sts	0x0081, r24

    OCR1A = 0;
     a02:	10 92 89 00 	sts	0x0089, r1
     a06:	10 92 88 00 	sts	0x0088, r1
    OCR1B = 0;
     a0a:	10 92 8b 00 	sts	0x008B, r1
     a0e:	10 92 8a 00 	sts	0x008A, r1

    BIT_CLEAR( PRR, PRTIM1 );
     a12:	e4 e6       	ldi	r30, 0x64	; 100
     a14:	f0 e0       	ldi	r31, 0x00	; 0
     a16:	80 81       	ld	r24, Z
     a18:	87 7f       	andi	r24, 0xF7	; 247
     a1a:	80 83       	st	Z, r24

    // TODO remove
    MOTORS_ENABLE();
     a1c:	40 9a       	sbi	0x08, 0	; 8

    Motors_Set_Direction(MOTORS_L_INDEX, MOTORS_BRAKE);
     a1e:	80 e0       	ldi	r24, 0x00	; 0
     a20:	60 e0       	ldi	r22, 0x00	; 0
     a22:	0e 94 a0 04 	call	0x940	; 0x940 <Motors_Set_Direction>
    Motors_Set_Direction(MOTORS_R_INDEX, MOTORS_BRAKE);
     a26:	81 e0       	ldi	r24, 0x01	; 1
     a28:	60 e0       	ldi	r22, 0x00	; 0
     a2a:	0e 94 a0 04 	call	0x940	; 0x940 <Motors_Set_Direction>

    return ;
}
     a2e:	08 95       	ret

00000a30 <Motors_Set_Power>:

/** Sets the PWM power for the appropriate motor.
 */
void Motors_Set_Power( uint8_t motor_index, uint8_t motor_power)
{
    if (MOTORS_L_INDEX == motor_index)
     a30:	88 23       	and	r24, r24
     a32:	39 f4       	brne	.+14     	; 0xa42 <Motors_Set_Power+0x12>
    {
        MOTORS_L_POWER = motor_power;
     a34:	86 2f       	mov	r24, r22
     a36:	90 e0       	ldi	r25, 0x00	; 0
     a38:	90 93 8b 00 	sts	0x008B, r25
     a3c:	80 93 8a 00 	sts	0x008A, r24
     a40:	08 95       	ret
    }
    else if (MOTORS_R_INDEX == motor_index)
     a42:	81 30       	cpi	r24, 0x01	; 1
     a44:	31 f4       	brne	.+12     	; 0xa52 <Motors_Set_Power+0x22>
    {
        MOTORS_R_POWER = motor_power;
     a46:	86 2f       	mov	r24, r22
     a48:	90 e0       	ldi	r25, 0x00	; 0
     a4a:	90 93 89 00 	sts	0x0089, r25
     a4e:	80 93 88 00 	sts	0x0088, r24
     a52:	08 95       	ret

00000a54 <Shaft_Encoders_Init>:
/** Initializes the AVR
*/
void Shaft_Encoders_Init( void  )
{
    // Set pins as input
    INPUT_PIN( ENCODERS_LEFT_TICKS_PORT, ENCODERS_LEFT_TICKS_PIN );
     a54:	53 98       	cbi	0x0a, 3	; 10
    INPUT_PIN( ENCODERS_LEFT_DIR_PORT, ENCODERS_LEFT_DIR_PIN );
     a56:	55 98       	cbi	0x0a, 5	; 10

    INPUT_PIN( ENCODERS_RIGHT_TICKS_PORT, ENCODERS_RIGHT_TICKS_PIN );
     a58:	52 98       	cbi	0x0a, 2	; 10
    INPUT_PIN( ENCODERS_RIGHT_DIR_PORT, ENCODERS_RIGHT_DIR_PIN );
     a5a:	54 98       	cbi	0x0a, 4	; 10
    INPUT_PIN( ENCODERS_STASIS_TICKS_PORT, ENCODERS_STASIS_TICKS_PIN );
    INPUT_PIN( ENCODERS_STASIS_DIR_PORT, ENCODERS_STASIS_DIR_PIN );
#endif

    // Disable pull-up
    DISABLE_PULLUP( ENCODERS_LEFT_TICKS_PORT, ENCODERS_LEFT_TICKS_PIN );
     a5c:	5b 98       	cbi	0x0b, 3	; 11
    DISABLE_PULLUP( ENCODERS_RIGHT_TICKS_PORT, ENCODERS_RIGHT_TICKS_PIN );
     a5e:	5a 98       	cbi	0x0b, 2	; 11

    DISABLE_PULLUP( ENCODERS_LEFT_DIR_PORT, ENCODERS_LEFT_DIR_PIN );
     a60:	5d 98       	cbi	0x0b, 5	; 11
    DISABLE_PULLUP( ENCODERS_RIGHT_DIR_PORT, ENCODERS_RIGHT_DIR_PIN );
     a62:	5c 98       	cbi	0x0b, 4	; 11

    // Set interupts as rising edge triggered
    EICRA |= ENCODERS_EICRA_MASK;
     a64:	e9 e6       	ldi	r30, 0x69	; 105
     a66:	f0 e0       	ldi	r31, 0x00	; 0
     a68:	80 81       	ld	r24, Z
     a6a:	85 60       	ori	r24, 0x05	; 5
     a6c:	80 83       	st	Z, r24
#if STATIS_WHEEL_EN
    EICRB |= STASIS_EICRB_MASK;  
#endif

    // Enable the interupts - Interrupts should be globally disabled
    EIMSK |= BIT( ENCODERS_LEFT_INTERRUPT ) | BIT( ENCODERS_RIGHT_INTERRUPT );
     a6e:	8d b3       	in	r24, 0x1d	; 29
     a70:	83 60       	ori	r24, 0x03	; 3
     a72:	8d bb       	out	0x1d, r24	; 29

#if STATIS_WHEEL_EN
    EIMSK |= BIT ( STASIS_WHEEL_INTERRUPT );
#endif
}
     a74:	08 95       	ret

00000a76 <__vector_2>:
 
ISR( ENCODERS_LEFT_INT_VECT )
{ 
     a76:	1f 92       	push	r1
     a78:	0f 92       	push	r0
     a7a:	0f b6       	in	r0, 0x3f	; 63
     a7c:	0f 92       	push	r0
     a7e:	11 24       	eor	r1, r1
     a80:	8f 93       	push	r24
     a82:	9f 93       	push	r25
    if ( READ_PIN( ENCODERS_LEFT_DIR_PORT, ENCODERS_LEFT_DIR_PIN ) )
     a84:	89 b1       	in	r24, 0x09	; 9
     a86:	82 95       	swap	r24
     a88:	86 95       	lsr	r24
     a8a:	87 70       	andi	r24, 0x07	; 7
     a8c:	80 ff       	sbrs	r24, 0
     a8e:	06 c0       	rjmp	.+12     	; 0xa9c <__vector_2+0x26>
    {
        --g_shaft_encoders_left_count;
     a90:	80 91 63 01 	lds	r24, 0x0163
     a94:	90 91 64 01 	lds	r25, 0x0164
     a98:	01 97       	sbiw	r24, 0x01	; 1
     a9a:	05 c0       	rjmp	.+10     	; 0xaa6 <__vector_2+0x30>
    }
    else
    {
        ++g_shaft_encoders_left_count;
     a9c:	80 91 63 01 	lds	r24, 0x0163
     aa0:	90 91 64 01 	lds	r25, 0x0164
     aa4:	01 96       	adiw	r24, 0x01	; 1
     aa6:	90 93 64 01 	sts	0x0164, r25
     aaa:	80 93 63 01 	sts	0x0163, r24
    }
}
     aae:	9f 91       	pop	r25
     ab0:	8f 91       	pop	r24
     ab2:	0f 90       	pop	r0
     ab4:	0f be       	out	0x3f, r0	; 63
     ab6:	0f 90       	pop	r0
     ab8:	1f 90       	pop	r1
     aba:	18 95       	reti

00000abc <__vector_1>:

ISR( ENCODERS_RIGHT_INT_VECT )
{
     abc:	1f 92       	push	r1
     abe:	0f 92       	push	r0
     ac0:	0f b6       	in	r0, 0x3f	; 63
     ac2:	0f 92       	push	r0
     ac4:	11 24       	eor	r1, r1
     ac6:	8f 93       	push	r24
     ac8:	9f 93       	push	r25
    if ( READ_PIN( ENCODERS_RIGHT_DIR_PORT, ENCODERS_RIGHT_DIR_PIN ) )
     aca:	89 b1       	in	r24, 0x09	; 9
     acc:	82 95       	swap	r24
     ace:	8f 70       	andi	r24, 0x0F	; 15
     ad0:	80 ff       	sbrs	r24, 0
     ad2:	06 c0       	rjmp	.+12     	; 0xae0 <__vector_1+0x24>
    {
        ++g_shaft_encoders_right_count;
     ad4:	80 91 65 01 	lds	r24, 0x0165
     ad8:	90 91 66 01 	lds	r25, 0x0166
     adc:	01 96       	adiw	r24, 0x01	; 1
     ade:	05 c0       	rjmp	.+10     	; 0xaea <__vector_1+0x2e>
    }
    else
    {
        --g_shaft_encoders_right_count;
     ae0:	80 91 65 01 	lds	r24, 0x0165
     ae4:	90 91 66 01 	lds	r25, 0x0166
     ae8:	01 97       	sbiw	r24, 0x01	; 1
     aea:	90 93 66 01 	sts	0x0166, r25
     aee:	80 93 65 01 	sts	0x0165, r24
    }
}  
     af2:	9f 91       	pop	r25
     af4:	8f 91       	pop	r24
     af6:	0f 90       	pop	r0
     af8:	0f be       	out	0x3f, r0	; 63
     afa:	0f 90       	pop	r0
     afc:	1f 90       	pop	r1
     afe:	18 95       	reti

00000b00 <TWI_Slave_Initialise>:
The TWI module is configured to NACK on any requests. Use a TWI_Start_Transceiver function to 
start the TWI.
****************************************************************************/
void TWI_Slave_Initialise( unsigned char TWI_ownAddress )
{
  TWAR = TWI_ownAddress;                            // Set own TWI slave address. Accept TWI General Calls.
     b00:	80 93 ba 00 	sts	0x00BA, r24
  TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
     b04:	84 e0       	ldi	r24, 0x04	; 4
     b06:	80 93 bc 00 	sts	0x00BC, r24
         (0<<TWIE)|(0<<TWINT)|                      // Disable TWI Interupt.
         (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Do not ACK on any requests, yet.
         (0<<TWWC);                                 //
  TWI_busy = 0;
     b0a:	10 92 6e 01 	sts	0x016E, r1

  BIT_CLEAR( PRR, PRTWI );
     b0e:	e4 e6       	ldi	r30, 0x64	; 100
     b10:	f0 e0       	ldi	r31, 0x00	; 0
     b12:	80 81       	ld	r24, Z
     b14:	8f 77       	andi	r24, 0x7F	; 127
     b16:	80 83       	st	Z, r24
}    
     b18:	08 95       	ret

00000b1a <TWI_Transceiver_Busy>:
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return TWI_busy;
}
     b1a:	80 91 6e 01 	lds	r24, 0x016E
     b1e:	08 95       	ret

00000b20 <TWI_Get_State_Info>:
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
  while ( TWI_Transceiver_Busy() ) {}             // Wait until TWI has completed the transmission.
     b20:	80 91 6e 01 	lds	r24, 0x016E
     b24:	88 23       	and	r24, r24
     b26:	19 f4       	brne	.+6      	; 0xb2e <TWI_Get_State_Info+0xe>
  return ( TWI_state );                         // Return error state. 
}
     b28:	80 91 01 01 	lds	r24, 0x0101
     b2c:	08 95       	ret
     b2e:	ff cf       	rjmp	.-2      	; 0xb2e <TWI_Get_State_Info+0xe>

00000b30 <TWI_Start_Transceiver_With_Data>:
Address byte is not included in the message buffers.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
     b30:	9c 01       	movw	r18, r24
  unsigned char temp;

  while ( TWI_Transceiver_Busy() ) {}             // Wait until TWI is ready for next transmission.
     b32:	80 91 6e 01 	lds	r24, 0x016E
     b36:	88 23       	and	r24, r24
     b38:	e1 f4       	brne	.+56     	; 0xb72 <TWI_Start_Transceiver_With_Data+0x42>

  TWI_msgSize = msgSize;                        // Number of data to transmit.
     b3a:	60 93 72 01 	sts	0x0172, r22
     b3e:	d9 01       	movw	r26, r18
     b40:	90 e0       	ldi	r25, 0x00	; 0
     b42:	09 c0       	rjmp	.+18     	; 0xb56 <TWI_Start_Transceiver_With_Data+0x26>
  for ( temp = 0; temp < msgSize; temp++ )      // Copy data that may be transmitted if the TWI Master requests data.
  {
    gp_TWI_transmitBuf[ temp ] = msg[ temp ];
     b44:	e0 91 cb 01 	lds	r30, 0x01CB
     b48:	f0 91 cc 01 	lds	r31, 0x01CC
     b4c:	e9 0f       	add	r30, r25
     b4e:	f1 1d       	adc	r31, r1
     b50:	8d 91       	ld	r24, X+
     b52:	80 83       	st	Z, r24
  unsigned char temp;

  while ( TWI_Transceiver_Busy() ) {}             // Wait until TWI is ready for next transmission.

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  for ( temp = 0; temp < msgSize; temp++ )      // Copy data that may be transmitted if the TWI Master requests data.
     b54:	9f 5f       	subi	r25, 0xFF	; 255
     b56:	96 17       	cp	r25, r22
     b58:	a8 f3       	brcs	.-22     	; 0xb44 <TWI_Start_Transceiver_With_Data+0x14>
  {
    gp_TWI_transmitBuf[ temp ] = msg[ temp ];
  }
  TWI_statusReg.all = 0;      
     b5a:	10 92 6d 01 	sts	0x016D, r1
  TWI_state         = TWI_NO_STATE ;
     b5e:	88 ef       	ldi	r24, 0xF8	; 248
     b60:	80 93 01 01 	sts	0x0101, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
     b64:	85 ec       	ldi	r24, 0xC5	; 197
     b66:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|       // Prepare to ACK next time the Slave is addressed.
         (0<<TWWC);                             //
  TWI_busy = 1;
     b6a:	81 e0       	ldi	r24, 0x01	; 1
     b6c:	80 93 6e 01 	sts	0x016E, r24
}
     b70:	08 95       	ret
     b72:	ff cf       	rjmp	.-2      	; 0xb72 <TWI_Start_Transceiver_With_Data+0x42>

00000b74 <TWI_Start_Transceiver>:
in the transceiver buffers. The function will hold execution (loop) until the TWI_ISR has completed with the 
previous operation, then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() ) {}             // Wait until TWI is ready for next transmission.
     b74:	80 91 6e 01 	lds	r24, 0x016E
     b78:	88 23       	and	r24, r24
     b7a:	59 f4       	brne	.+22     	; 0xb92 <TWI_Start_Transceiver+0x1e>
  TWI_statusReg.all = 0;      
     b7c:	10 92 6d 01 	sts	0x016D, r1
  TWI_state         = TWI_NO_STATE ;
     b80:	88 ef       	ldi	r24, 0xF8	; 248
     b82:	80 93 01 01 	sts	0x0101, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
     b86:	85 ec       	ldi	r24, 0xC5	; 197
     b88:	80 93 bc 00 	sts	0x00BC, r24
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
         (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|       // Prepare to ACK next time the Slave is addressed.
         (0<<TWWC);                             //
  TWI_busy = 0;
     b8c:	10 92 6e 01 	sts	0x016E, r1
}
     b90:	08 95       	ret
     b92:	ff cf       	rjmp	.-2      	; 0xb92 <TWI_Start_Transceiver+0x1e>

00000b94 <TWI_Get_Data_From_Transceiver>:
to fetch in the function call. The function will hold execution (loop) until the TWI_ISR has completed 
with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI State code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
     b94:	9c 01       	movw	r18, r24
  unsigned char i;

  while ( TWI_Transceiver_Busy() ) {}             // Wait until TWI is ready for next transmission.
     b96:	80 91 6e 01 	lds	r24, 0x016E
     b9a:	88 23       	and	r24, r24
     b9c:	d9 f4       	brne	.+54     	; 0xbd4 <TWI_Get_Data_From_Transceiver+0x40>

  if( TWI_statusReg.lastTransOK )               // Last transmission completed successfully.              
     b9e:	80 91 6d 01 	lds	r24, 0x016D
     ba2:	80 ff       	sbrs	r24, 0
     ba4:	13 c0       	rjmp	.+38     	; 0xbcc <TWI_Get_Data_From_Transceiver+0x38>
     ba6:	d9 01       	movw	r26, r18
     ba8:	90 e0       	ldi	r25, 0x00	; 0
     baa:	09 c0       	rjmp	.+18     	; 0xbbe <TWI_Get_Data_From_Transceiver+0x2a>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    {
      msg[ i ] = gp_TWI_receive_buf[ i ];
     bac:	e0 91 c9 01 	lds	r30, 0x01C9
     bb0:	f0 91 ca 01 	lds	r31, 0x01CA
     bb4:	e9 0f       	add	r30, r25
     bb6:	f1 1d       	adc	r31, r1
     bb8:	80 81       	ld	r24, Z
     bba:	8d 93       	st	X+, r24

  while ( TWI_Transceiver_Busy() ) {}             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission completed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
     bbc:	9f 5f       	subi	r25, 0xFF	; 255
     bbe:	96 17       	cp	r25, r22
     bc0:	a8 f3       	brcs	.-22     	; 0xbac <TWI_Get_Data_From_Transceiver+0x18>
    {
      msg[ i ] = gp_TWI_receive_buf[ i ];
    }
    TWI_statusReg.RxDataInBuf = FALSE;          // Slave Receive data has been read from buffer.
     bc2:	80 91 6d 01 	lds	r24, 0x016D
     bc6:	8d 7f       	andi	r24, 0xFD	; 253
     bc8:	80 93 6d 01 	sts	0x016D, r24
     bcc:	80 91 6d 01 	lds	r24, 0x016D
  }
  return( TWI_statusReg.lastTransOK );                                   
}
     bd0:	81 70       	andi	r24, 0x01	; 1
     bd2:	08 95       	ret
     bd4:	ff cf       	rjmp	.-2      	; 0xbd4 <TWI_Get_Data_From_Transceiver+0x40>

00000bd6 <__vector_24>:
This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR( TWI_vect )
{
     bd6:	1f 92       	push	r1
     bd8:	0f 92       	push	r0
     bda:	0f b6       	in	r0, 0x3f	; 63
     bdc:	0f 92       	push	r0
     bde:	11 24       	eor	r1, r1
     be0:	2f 93       	push	r18
     be2:	8f 93       	push	r24
     be4:	9f 93       	push	r25
     be6:	ef 93       	push	r30
     be8:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  static unsigned char TWI_numBytes;
  static unsigned char TWI_multiByteWrite = FALSE;

  switch (TWSR)
     bea:	80 91 b9 00 	lds	r24, 0x00B9
     bee:	80 39       	cpi	r24, 0x90	; 144
     bf0:	09 f4       	brne	.+2      	; 0xbf4 <__vector_24+0x1e>
     bf2:	55 c0       	rjmp	.+170    	; 0xc9e <__vector_24+0xc8>
     bf4:	81 39       	cpi	r24, 0x91	; 145
     bf6:	90 f4       	brcc	.+36     	; 0xc1c <__vector_24+0x46>
     bf8:	80 37       	cpi	r24, 0x70	; 112
     bfa:	f1 f1       	breq	.+124    	; 0xc78 <__vector_24+0xa2>
     bfc:	81 37       	cpi	r24, 0x71	; 113
     bfe:	38 f4       	brcc	.+14     	; 0xc0e <__vector_24+0x38>
     c00:	88 23       	and	r24, r24
     c02:	09 f4       	brne	.+2      	; 0xc06 <__vector_24+0x30>
     c04:	8d c0       	rjmp	.+282    	; 0xd20 <__vector_24+0x14a>
     c06:	80 36       	cpi	r24, 0x60	; 96
     c08:	09 f0       	breq	.+2      	; 0xc0c <__vector_24+0x36>
     c0a:	92 c0       	rjmp	.+292    	; 0xd30 <__vector_24+0x15a>
     c0c:	3a c0       	rjmp	.+116    	; 0xc82 <__vector_24+0xac>
     c0e:	80 38       	cpi	r24, 0x80	; 128
     c10:	09 f4       	brne	.+2      	; 0xc14 <__vector_24+0x3e>
     c12:	45 c0       	rjmp	.+138    	; 0xc9e <__vector_24+0xc8>
     c14:	88 38       	cpi	r24, 0x88	; 136
     c16:	09 f0       	breq	.+2      	; 0xc1a <__vector_24+0x44>
     c18:	8b c0       	rjmp	.+278    	; 0xd30 <__vector_24+0x15a>
     c1a:	82 c0       	rjmp	.+260    	; 0xd20 <__vector_24+0x14a>
     c1c:	88 3a       	cpi	r24, 0xA8	; 168
     c1e:	91 f0       	breq	.+36     	; 0xc44 <__vector_24+0x6e>
     c20:	89 3a       	cpi	r24, 0xA9	; 169
     c22:	38 f4       	brcc	.+14     	; 0xc32 <__vector_24+0x5c>
     c24:	88 39       	cpi	r24, 0x98	; 152
     c26:	09 f4       	brne	.+2      	; 0xc2a <__vector_24+0x54>
     c28:	7b c0       	rjmp	.+246    	; 0xd20 <__vector_24+0x14a>
     c2a:	80 3a       	cpi	r24, 0xA0	; 160
     c2c:	09 f0       	breq	.+2      	; 0xc30 <__vector_24+0x5a>
     c2e:	80 c0       	rjmp	.+256    	; 0xd30 <__vector_24+0x15a>
     c30:	5d c0       	rjmp	.+186    	; 0xcec <__vector_24+0x116>
     c32:	80 3c       	cpi	r24, 0xC0	; 192
     c34:	d9 f0       	breq	.+54     	; 0xc6c <__vector_24+0x96>
     c36:	88 3c       	cpi	r24, 0xC8	; 200
     c38:	09 f4       	brne	.+2      	; 0xc3c <__vector_24+0x66>
     c3a:	72 c0       	rjmp	.+228    	; 0xd20 <__vector_24+0x14a>
     c3c:	88 3b       	cpi	r24, 0xB8	; 184
     c3e:	09 f0       	breq	.+2      	; 0xc42 <__vector_24+0x6c>
     c40:	77 c0       	rjmp	.+238    	; 0xd30 <__vector_24+0x15a>
     c42:	05 c0       	rjmp	.+10     	; 0xc4e <__vector_24+0x78>
  {
    case TWI_STX_ADR_ACK:            // Own SLA+R has been received; ACK has been returned
//    case TWI_STX_ADR_ACK_M_ARB_LOST: // Arbitration lost in SLA+R/W as Master; own SLA+R has been received; ACK has been returned
      TWI_numBytes = 0;                                 // Set buffer pointer to first data location
     c44:	10 92 70 01 	sts	0x0170, r1
      g_TWI_readInProgress = TRUE;
     c48:	81 e0       	ldi	r24, 0x01	; 1
     c4a:	80 93 6b 01 	sts	0x016B, r24
    case TWI_STX_DATA_ACK:           // Data byte in TWDR has been transmitted; ACK has been received
      TWDR = gp_TWI_transmitBuf[TWI_bufPtr++];
     c4e:	90 91 71 01 	lds	r25, 0x0171
     c52:	e0 91 cb 01 	lds	r30, 0x01CB
     c56:	f0 91 cc 01 	lds	r31, 0x01CC
     c5a:	e9 0f       	add	r30, r25
     c5c:	f1 1d       	adc	r31, r1
     c5e:	80 81       	ld	r24, Z
     c60:	80 93 bb 00 	sts	0x00BB, r24
     c64:	9f 5f       	subi	r25, 0xFF	; 255
     c66:	90 93 71 01 	sts	0x0171, r25
     c6a:	12 c0       	rjmp	.+36     	; 0xc90 <__vector_24+0xba>
             (0<<TWWC);                                 //
      TWI_busy = 1;
      break;
    case TWI_STX_DATA_NACK:          // Data byte in TWDR has been transmitted; NACK has been received. 
                                     // I.e. this could be the end of the transmission. -SJL Assume to be true
      TWI_statusReg.lastTransOK = TRUE;               // Set status bits to completed successfully. 
     c6c:	80 91 6d 01 	lds	r24, 0x016D
     c70:	81 60       	ori	r24, 0x01	; 1
     c72:	80 93 6d 01 	sts	0x016D, r24
     c76:	3a c0       	rjmp	.+116    	; 0xcec <__vector_24+0x116>
      }

      break;     
    case TWI_SRX_GEN_ACK:            // General call address has been received; ACK has been returned
//    case TWI_SRX_GEN_ACK_M_ARB_LOST: // Arbitration lost in SLA+R/W as Master; General call address has been received; ACK has been returned
      TWI_statusReg.genAddressCall = TRUE;
     c78:	80 91 6d 01 	lds	r24, 0x016D
     c7c:	84 60       	ori	r24, 0x04	; 4
     c7e:	80 93 6d 01 	sts	0x016D, r24
    case TWI_SRX_ADR_ACK:            // Own SLA+W has been received ACK has been returned
//    case TWI_SRX_ADR_ACK_M_ARB_LOST: // Arbitration lost in SLA+R/W as Master; own SLA+W has been received; ACK has been returned    
                                                        // Dont need to clear TWI_S_statusRegister.generalAddressCall due to that it is the default state.
      TWI_statusReg.RxDataInBuf = TRUE;      
     c82:	80 91 6d 01 	lds	r24, 0x016D
     c86:	82 60       	ori	r24, 0x02	; 2
     c88:	80 93 6d 01 	sts	0x016D, r24
      //TWI_bufPtr   = 0;                                 // Set buffer pointer to first data location
      TWI_numBytes = 0;  
     c8c:	10 92 70 01 	sts	0x0170, r1
                                                        // Reset the TWI Interupt to wait for a new event.
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     c90:	85 ec       	ldi	r24, 0xC5	; 197
     c92:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
             (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Expect ACK on this transmission
             (0<<TWWC);  
      TWI_busy = 1;
     c96:	81 e0       	ldi	r24, 0x01	; 1
     c98:	80 93 6e 01 	sts	0x016E, r24
     c9c:	52 c0       	rjmp	.+164    	; 0xd42 <__vector_24+0x16c>
      
      break;
    case TWI_SRX_ADR_DATA_ACK:       // Previously addressed with own SLA+W; data has been received; ACK has been returned
    case TWI_SRX_GEN_DATA_ACK:       // Previously addressed with general call; data has been received; ACK has been returned
      if ( 0 == TWI_numBytes )        // Set the register offset to read/write from
     c9e:	20 91 70 01 	lds	r18, 0x0170
     ca2:	22 23       	and	r18, r18
     ca4:	39 f4       	brne	.+14     	; 0xcb4 <__vector_24+0xde>
      {
        TWI_bufPtr = TWDR;
     ca6:	80 91 bb 00 	lds	r24, 0x00BB
     caa:	80 93 71 01 	sts	0x0171, r24
        TWI_multiByteWrite = FALSE;
     cae:	10 92 6f 01 	sts	0x016F, r1
     cb2:	13 c0       	rjmp	.+38     	; 0xcda <__vector_24+0x104>
      }
      else
      {
        gp_TWI_receive_buf[TWI_bufPtr++]     = TWDR;
     cb4:	90 91 71 01 	lds	r25, 0x0171
     cb8:	e0 91 c9 01 	lds	r30, 0x01C9
     cbc:	f0 91 ca 01 	lds	r31, 0x01CA
     cc0:	e9 0f       	add	r30, r25
     cc2:	f1 1d       	adc	r31, r1
     cc4:	80 91 bb 00 	lds	r24, 0x00BB
     cc8:	80 83       	st	Z, r24
     cca:	9f 5f       	subi	r25, 0xFF	; 255
     ccc:	90 93 71 01 	sts	0x0171, r25
        TWI_multiByteWrite = TRUE;
     cd0:	81 e0       	ldi	r24, 0x01	; 1
     cd2:	80 93 6f 01 	sts	0x016F, r24
        g_TWI_writeInProgress = TRUE;
     cd6:	80 93 6c 01 	sts	0x016C, r24
      }

      TWI_numBytes++;
     cda:	2f 5f       	subi	r18, 0xFF	; 255
     cdc:	20 93 70 01 	sts	0x0170, r18

      TWI_statusReg.lastTransOK = TRUE;                 // Set flag transmission successfull.       
     ce0:	80 91 6d 01 	lds	r24, 0x016D
     ce4:	81 60       	ori	r24, 0x01	; 1
     ce6:	80 93 6d 01 	sts	0x016D, r24
     cea:	d2 cf       	rjmp	.-92     	; 0xc90 <__vector_24+0xba>
             (0<<TWWC);                                 // 
      TWI_busy = 1;
      break;
    case TWI_SRX_STOP_RESTART:       // A STOP condition or repeated START condition has been received while still addressed as Slave    
                                                        // Enter not addressed mode and listen to address match
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
     cec:	85 ec       	ldi	r24, 0xC5	; 197
     cee:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Enable interrupt and clear the flag
             (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Wait for new address match
             (0<<TWWC);                                 //
      
      TWI_busy = 0;  // We are waiting for a new address match, so we are not busy
     cf2:	10 92 6e 01 	sts	0x016E, r1

      if (TWI_multiByteWrite)
     cf6:	80 91 6f 01 	lds	r24, 0x016F
     cfa:	88 23       	and	r24, r24
     cfc:	39 f0       	breq	.+14     	; 0xd0c <__vector_24+0x136>
      {
        TWI_multiByteWrite = FALSE;
     cfe:	10 92 6f 01 	sts	0x016F, r1
        g_TWI_writeInProgress = FALSE;
     d02:	10 92 6c 01 	sts	0x016C, r1
        g_TWI_writeComplete = TRUE;
     d06:	81 e0       	ldi	r24, 0x01	; 1
     d08:	80 93 6a 01 	sts	0x016A, r24
      }

      if ( g_TWI_readInProgress )
     d0c:	80 91 6b 01 	lds	r24, 0x016B
     d10:	88 23       	and	r24, r24
     d12:	b9 f0       	breq	.+46     	; 0xd42 <__vector_24+0x16c>
      {
        g_TWI_readInProgress = FALSE;
     d14:	10 92 6b 01 	sts	0x016B, r1
        g_TWI_readComplete = TRUE;
     d18:	81 e0       	ldi	r24, 0x01	; 1
     d1a:	80 93 69 01 	sts	0x0169, r24
     d1e:	11 c0       	rjmp	.+34     	; 0xd42 <__vector_24+0x16c>
    case TWI_SRX_ADR_DATA_NACK:      // Previously addressed with own SLA+W; data has been received; NOT ACK has been returned
    case TWI_SRX_GEN_DATA_NACK:      // Previously addressed with general call; data has been received; NOT ACK has been returned
    case TWI_STX_DATA_ACK_LAST_BYTE: // Last data byte in TWDR has been transmitted (TWEA = 0); ACK has been received
//    case TWI_NO_STATE              // No relevant state information available; TWINT = 0
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
      TWI_state = TWSR;                 //Store TWI State as errormessage, operation also clears noErrors bit
     d20:	80 91 b9 00 	lds	r24, 0x00B9
     d24:	80 93 01 01 	sts	0x0101, r24
      TWCR =   (1<<TWSTO)|(1<<TWINT);   //Recover from TWI_BUS_ERROR, this will release the SDA and SCL pins thus enabling other devices to use the bus
     d28:	80 e9       	ldi	r24, 0x90	; 144
     d2a:	80 93 bc 00 	sts	0x00BC, r24
     d2e:	09 c0       	rjmp	.+18     	; 0xd42 <__vector_24+0x16c>
      break;
    default:     
      TWI_state = TWSR;                                 // Store TWI State as errormessage, operation also clears the Success bit.      
     d30:	80 91 b9 00 	lds	r24, 0x00B9
     d34:	80 93 01 01 	sts	0x0101, r24
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
     d38:	85 ec       	ldi	r24, 0xC5	; 197
     d3a:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Keep interrupt enabled and clear the flag
             (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Acknowledge on any new requests.
             (0<<TWWC);                                 //
      
      TWI_busy = 0; // Unknown status, so we wait for a new address match that might be something we can handle
     d3e:	10 92 6e 01 	sts	0x016E, r1
  }
}
     d42:	ff 91       	pop	r31
     d44:	ef 91       	pop	r30
     d46:	9f 91       	pop	r25
     d48:	8f 91       	pop	r24
     d4a:	2f 91       	pop	r18
     d4c:	0f 90       	pop	r0
     d4e:	0f be       	out	0x3f, r0	; 63
     d50:	0f 90       	pop	r0
     d52:	1f 90       	pop	r1
     d54:	18 95       	reti

00000d56 <CRC8_Update>:
    return crc;
}

void 
CRC8_Update( uint8_t new_byte, uint8_t * const current_crc )
{
     d56:	38 2f       	mov	r19, r24
     d58:	fb 01       	movw	r30, r22
   uint8_t new_crc;

   new_crc = *current_crc;
     d5a:	90 81       	ld	r25, Z
     d5c:	20 e0       	ldi	r18, 0x00	; 0

   for (uint8_t i = 0; i < 8; i++) 
   {
      if ((new_crc ^ new_byte) & 1) 
      {
         new_crc = (new_crc >> 1 ) ^ POLYVAL;
     d5e:	4c e8       	ldi	r20, 0x8C	; 140

   new_crc = *current_crc;

   for (uint8_t i = 0; i < 8; i++) 
   {
      if ((new_crc ^ new_byte) & 1) 
     d60:	89 2f       	mov	r24, r25
     d62:	83 27       	eor	r24, r19
     d64:	96 95       	lsr	r25
     d66:	80 fd       	sbrc	r24, 0
      {
         new_crc = (new_crc >> 1 ) ^ POLYVAL;
     d68:	94 27       	eor	r25, r20
{
   uint8_t new_crc;

   new_crc = *current_crc;

   for (uint8_t i = 0; i < 8; i++) 
     d6a:	2f 5f       	subi	r18, 0xFF	; 255
     d6c:	28 30       	cpi	r18, 0x08	; 8
     d6e:	11 f0       	breq	.+4      	; 0xd74 <CRC8_Update+0x1e>
      else 
      {
         new_crc >>= 1;
      }

      new_byte >>= 1;
     d70:	36 95       	lsr	r19
     d72:	f6 cf       	rjmp	.-20     	; 0xd60 <CRC8_Update+0xa>
   }

   *current_crc = new_crc;
     d74:	90 83       	st	Z, r25
}
     d76:	08 95       	ret

00000d78 <CRC8_Checksum>:
 *
 *  @returns    The calculated checksum.
 */
uint8_t
CRC8_Checksum( uint8_t *data, uint32_t num_bytes, uint8_t seed )
{
     d78:	6f 92       	push	r6
     d7a:	7f 92       	push	r7
     d7c:	8f 92       	push	r8
     d7e:	9f 92       	push	r9
     d80:	af 92       	push	r10
     d82:	bf 92       	push	r11
     d84:	cf 92       	push	r12
     d86:	df 92       	push	r13
     d88:	ef 92       	push	r14
     d8a:	ff 92       	push	r15
     d8c:	0f 93       	push	r16
     d8e:	1f 93       	push	r17
     d90:	df 93       	push	r29
     d92:	cf 93       	push	r28
     d94:	0f 92       	push	r0
     d96:	cd b7       	in	r28, 0x3d	; 61
     d98:	de b7       	in	r29, 0x3e	; 62
     d9a:	4c 01       	movw	r8, r24
     d9c:	5a 01       	movw	r10, r20
     d9e:	6b 01       	movw	r12, r22
    uint8_t crc = seed;
     da0:	29 83       	std	Y+1, r18	; 0x01
     da2:	ee 24       	eor	r14, r14
     da4:	ff 24       	eor	r15, r15
     da6:	87 01       	movw	r16, r14

    for (int i = 0; i < num_bytes; i++)
    {
        CRC8_Update(data[i], &crc); 
     da8:	3e 01       	movw	r6, r28
     daa:	08 94       	sec
     dac:	61 1c       	adc	r6, r1
     dae:	71 1c       	adc	r7, r1
     db0:	0c c0       	rjmp	.+24     	; 0xdca <CRC8_Checksum+0x52>
     db2:	f4 01       	movw	r30, r8
     db4:	ee 0d       	add	r30, r14
     db6:	ff 1d       	adc	r31, r15
     db8:	80 81       	ld	r24, Z
     dba:	b3 01       	movw	r22, r6
     dbc:	0e 94 ab 06 	call	0xd56	; 0xd56 <CRC8_Update>
     dc0:	08 94       	sec
     dc2:	e1 1c       	adc	r14, r1
     dc4:	f1 1c       	adc	r15, r1
     dc6:	01 1d       	adc	r16, r1
     dc8:	11 1d       	adc	r17, r1
uint8_t
CRC8_Checksum( uint8_t *data, uint32_t num_bytes, uint8_t seed )
{
    uint8_t crc = seed;

    for (int i = 0; i < num_bytes; i++)
     dca:	ea 14       	cp	r14, r10
     dcc:	fb 04       	cpc	r15, r11
     dce:	0c 05       	cpc	r16, r12
     dd0:	1d 05       	cpc	r17, r13
     dd2:	78 f3       	brcs	.-34     	; 0xdb2 <CRC8_Checksum+0x3a>
    {
        CRC8_Update(data[i], &crc); 
    }

    return crc;
}
     dd4:	89 81       	ldd	r24, Y+1	; 0x01
     dd6:	0f 90       	pop	r0
     dd8:	cf 91       	pop	r28
     dda:	df 91       	pop	r29
     ddc:	1f 91       	pop	r17
     dde:	0f 91       	pop	r16
     de0:	ff 90       	pop	r15
     de2:	ef 90       	pop	r14
     de4:	df 90       	pop	r13
     de6:	cf 90       	pop	r12
     de8:	bf 90       	pop	r11
     dea:	af 90       	pop	r10
     dec:	9f 90       	pop	r9
     dee:	8f 90       	pop	r8
     df0:	7f 90       	pop	r7
     df2:	6f 90       	pop	r6
     df4:	08 95       	ret

00000df6 <Clamp_Abs_Value>:
#include "clamp.h"

/** Clamps the value of p_to_clamp to within +-abs_max.
 */
uint8_t Clamp_Abs_Value(int16_t* p_to_clamp, int16_t abs_max)
{
     df6:	fc 01       	movw	r30, r24
     df8:	cb 01       	movw	r24, r22
     dfa:	77 ff       	sbrs	r23, 7
     dfc:	03 c0       	rjmp	.+6      	; 0xe04 <Clamp_Abs_Value+0xe>
     dfe:	90 95       	com	r25
     e00:	81 95       	neg	r24
     e02:	9f 4f       	sbci	r25, 0xFF	; 255
 */
uint8_t Clamp_Value(int16_t* p_to_clamp, int16_t min_value, int16_t max_value)
{
    uint8_t result = CLAMP_VALUE_IN_RANGE;

    if (*p_to_clamp > max_value)
     e04:	40 81       	ld	r20, Z
     e06:	51 81       	ldd	r21, Z+1	; 0x01
     e08:	84 17       	cp	r24, r20
     e0a:	95 07       	cpc	r25, r21
     e0c:	24 f4       	brge	.+8      	; 0xe16 <Clamp_Abs_Value+0x20>
    {
        *p_to_clamp = max_value;
     e0e:	91 83       	std	Z+1, r25	; 0x01
     e10:	80 83       	st	Z, r24
     e12:	81 e0       	ldi	r24, 0x01	; 1
     e14:	08 95       	ret
   if (abs_max < 0)
   {
      abs_max *= -1;
   }

   return Clamp_Value(p_to_clamp, (abs_max * -1), abs_max);
     e16:	22 27       	eor	r18, r18
     e18:	33 27       	eor	r19, r19
     e1a:	28 1b       	sub	r18, r24
     e1c:	39 0b       	sbc	r19, r25
    if (*p_to_clamp > max_value)
    {
        *p_to_clamp = max_value;
        result = CLAMP_VALUE_CLAMPED;
    }
    else if (*p_to_clamp < min_value)
     e1e:	42 17       	cp	r20, r18
     e20:	53 07       	cpc	r21, r19
     e22:	14 f0       	brlt	.+4      	; 0xe28 <Clamp_Abs_Value+0x32>
     e24:	80 e0       	ldi	r24, 0x00	; 0
     e26:	08 95       	ret
    {
        *p_to_clamp = min_value;
     e28:	31 83       	std	Z+1, r19	; 0x01
     e2a:	20 83       	st	Z, r18
     e2c:	81 e0       	ldi	r24, 0x01	; 1
   {
      abs_max *= -1;
   }

   return Clamp_Value(p_to_clamp, (abs_max * -1), abs_max);
}
     e2e:	08 95       	ret

00000e30 <Clamp_Value>:

/** Clamps the value of p_to_clamp to within min_value and max_value.
 */
uint8_t Clamp_Value(int16_t* p_to_clamp, int16_t min_value, int16_t max_value)
{
     e30:	fc 01       	movw	r30, r24
    uint8_t result = CLAMP_VALUE_IN_RANGE;

    if (*p_to_clamp > max_value)
     e32:	80 81       	ld	r24, Z
     e34:	91 81       	ldd	r25, Z+1	; 0x01
     e36:	48 17       	cp	r20, r24
     e38:	59 07       	cpc	r21, r25
     e3a:	24 f4       	brge	.+8      	; 0xe44 <Clamp_Value+0x14>
    {
        *p_to_clamp = max_value;
     e3c:	51 83       	std	Z+1, r21	; 0x01
     e3e:	40 83       	st	Z, r20
     e40:	81 e0       	ldi	r24, 0x01	; 1
     e42:	08 95       	ret
        result = CLAMP_VALUE_CLAMPED;
    }
    else if (*p_to_clamp < min_value)
     e44:	86 17       	cp	r24, r22
     e46:	97 07       	cpc	r25, r23
     e48:	14 f0       	brlt	.+4      	; 0xe4e <Clamp_Value+0x1e>
     e4a:	80 e0       	ldi	r24, 0x00	; 0
     e4c:	08 95       	ret
    {
        *p_to_clamp = min_value;
     e4e:	71 83       	std	Z+1, r23	; 0x01
     e50:	60 83       	st	Z, r22
     e52:	81 e0       	ldi	r24, 0x01	; 1
        result = CLAMP_VALUE_CLAMPED;
    }

    return result;
}
     e54:	08 95       	ret

00000e56 <Bin_to_AsciiHex>:
 *  single byte used for c-string termination.
 *
 */
    int
Bin_to_AsciiHex ( char ascii_out[], int data_length, uint8_t byte_buf[], char format[] )
{
     e56:	6f 92       	push	r6
     e58:	7f 92       	push	r7
     e5a:	8f 92       	push	r8
     e5c:	9f 92       	push	r9
     e5e:	af 92       	push	r10
     e60:	bf 92       	push	r11
     e62:	cf 92       	push	r12
     e64:	df 92       	push	r13
     e66:	ef 92       	push	r14
     e68:	ff 92       	push	r15
     e6a:	0f 93       	push	r16
     e6c:	1f 93       	push	r17
     e6e:	df 93       	push	r29
     e70:	cf 93       	push	r28
     e72:	cd b7       	in	r28, 0x3d	; 61
     e74:	de b7       	in	r29, 0x3e	; 62
     e76:	29 97       	sbiw	r28, 0x09	; 9
     e78:	0f b6       	in	r0, 0x3f	; 63
     e7a:	f8 94       	cli
     e7c:	de bf       	out	0x3e, r29	; 62
     e7e:	0f be       	out	0x3f, r0	; 63
     e80:	cd bf       	out	0x3d, r28	; 61
     e82:	3c 01       	movw	r6, r24
     e84:	4b 01       	movw	r8, r22
     e86:	5a 01       	movw	r10, r20
     e88:	69 01       	movw	r12, r18
    const char default_format[] = {"0x%0.2X "};
    int num_bytes = 0;

    if ((data_length > 0) && (byte_buf != NULL) && (ascii_out != NULL))
     e8a:	16 16       	cp	r1, r22
     e8c:	17 06       	cpc	r1, r23
     e8e:	0c f0       	brlt	.+2      	; 0xe92 <Bin_to_AsciiHex+0x3c>
     e90:	48 c0       	rjmp	.+144    	; 0xf22 <Bin_to_AsciiHex+0xcc>
     e92:	41 15       	cp	r20, r1
     e94:	51 05       	cpc	r21, r1
     e96:	09 f4       	brne	.+2      	; 0xe9a <Bin_to_AsciiHex+0x44>
     e98:	44 c0       	rjmp	.+136    	; 0xf22 <Bin_to_AsciiHex+0xcc>
     e9a:	00 97       	sbiw	r24, 0x00	; 0
     e9c:	09 f4       	brne	.+2      	; 0xea0 <Bin_to_AsciiHex+0x4a>
     e9e:	41 c0       	rjmp	.+130    	; 0xf22 <Bin_to_AsciiHex+0xcc>
    {
        if (NULL == format)
     ea0:	21 15       	cp	r18, r1
     ea2:	31 05       	cpc	r19, r1
     ea4:	21 f4       	brne	.+8      	; 0xeae <Bin_to_AsciiHex+0x58>
        {
            format = (char*) &default_format;
     ea6:	6e 01       	movw	r12, r28
     ea8:	08 94       	sec
     eaa:	c1 1c       	adc	r12, r1
     eac:	d1 1c       	adc	r13, r1
 *
 */
    int
Bin_to_AsciiHex ( char ascii_out[], int data_length, uint8_t byte_buf[], char format[] )
{
    const char default_format[] = {"0x%0.2X "};
     eae:	de 01       	movw	r26, r28
     eb0:	11 96       	adiw	r26, 0x01	; 1
     eb2:	e2 e0       	ldi	r30, 0x02	; 2
     eb4:	f1 e0       	ldi	r31, 0x01	; 1
     eb6:	89 e0       	ldi	r24, 0x09	; 9
     eb8:	01 90       	ld	r0, Z+
     eba:	0d 92       	st	X+, r0
     ebc:	81 50       	subi	r24, 0x01	; 1
     ebe:	e1 f7       	brne	.-8      	; 0xeb8 <Bin_to_AsciiHex+0x62>
     ec0:	00 e0       	ldi	r16, 0x00	; 0
     ec2:	10 e0       	ldi	r17, 0x00	; 0
     ec4:	ee 24       	eor	r14, r14
     ec6:	ff 24       	eor	r15, r15
            format = (char*) &default_format;
        }

        for (int i = 0; i < data_length; i++)
        {
            num_bytes += sprintf(&ascii_out[num_bytes], format, (unsigned char)byte_buf[i]);
     ec8:	00 d0       	rcall	.+0      	; 0xeca <Bin_to_AsciiHex+0x74>
     eca:	00 d0       	rcall	.+0      	; 0xecc <Bin_to_AsciiHex+0x76>
     ecc:	00 d0       	rcall	.+0      	; 0xece <Bin_to_AsciiHex+0x78>
     ece:	ad b7       	in	r26, 0x3d	; 61
     ed0:	be b7       	in	r27, 0x3e	; 62
     ed2:	11 96       	adiw	r26, 0x01	; 1
     ed4:	c3 01       	movw	r24, r6
     ed6:	80 0f       	add	r24, r16
     ed8:	91 1f       	adc	r25, r17
     eda:	ed b7       	in	r30, 0x3d	; 61
     edc:	fe b7       	in	r31, 0x3e	; 62
     ede:	92 83       	std	Z+2, r25	; 0x02
     ee0:	81 83       	std	Z+1, r24	; 0x01
     ee2:	13 96       	adiw	r26, 0x03	; 3
     ee4:	dc 92       	st	X, r13
     ee6:	ce 92       	st	-X, r12
     ee8:	12 97       	sbiw	r26, 0x02	; 2
     eea:	f5 01       	movw	r30, r10
     eec:	ee 0d       	add	r30, r14
     eee:	ff 1d       	adc	r31, r15
     ef0:	80 81       	ld	r24, Z
     ef2:	14 96       	adiw	r26, 0x04	; 4
     ef4:	8c 93       	st	X, r24
     ef6:	14 97       	sbiw	r26, 0x04	; 4
     ef8:	15 96       	adiw	r26, 0x05	; 5
     efa:	1c 92       	st	X, r1
     efc:	0e 94 95 08 	call	0x112a	; 0x112a <sprintf>
     f00:	08 0f       	add	r16, r24
     f02:	19 1f       	adc	r17, r25
        if (NULL == format)
        {
            format = (char*) &default_format;
        }

        for (int i = 0; i < data_length; i++)
     f04:	08 94       	sec
     f06:	e1 1c       	adc	r14, r1
     f08:	f1 1c       	adc	r15, r1
     f0a:	8d b7       	in	r24, 0x3d	; 61
     f0c:	9e b7       	in	r25, 0x3e	; 62
     f0e:	06 96       	adiw	r24, 0x06	; 6
     f10:	0f b6       	in	r0, 0x3f	; 63
     f12:	f8 94       	cli
     f14:	9e bf       	out	0x3e, r25	; 62
     f16:	0f be       	out	0x3f, r0	; 63
     f18:	8d bf       	out	0x3d, r24	; 61
     f1a:	e8 14       	cp	r14, r8
     f1c:	f9 04       	cpc	r15, r9
     f1e:	a4 f2       	brlt	.-88     	; 0xec8 <Bin_to_AsciiHex+0x72>
     f20:	02 c0       	rjmp	.+4      	; 0xf26 <Bin_to_AsciiHex+0xd0>
     f22:	00 e0       	ldi	r16, 0x00	; 0
     f24:	10 e0       	ldi	r17, 0x00	; 0
            num_bytes += sprintf(&ascii_out[num_bytes], format, (unsigned char)byte_buf[i]);
        }
    }

    return num_bytes;
}		/* Bin_to_AsciiHex */
     f26:	c8 01       	movw	r24, r16
     f28:	29 96       	adiw	r28, 0x09	; 9
     f2a:	0f b6       	in	r0, 0x3f	; 63
     f2c:	f8 94       	cli
     f2e:	de bf       	out	0x3e, r29	; 62
     f30:	0f be       	out	0x3f, r0	; 63
     f32:	cd bf       	out	0x3d, r28	; 61
     f34:	cf 91       	pop	r28
     f36:	df 91       	pop	r29
     f38:	1f 91       	pop	r17
     f3a:	0f 91       	pop	r16
     f3c:	ff 90       	pop	r15
     f3e:	ef 90       	pop	r14
     f40:	df 90       	pop	r13
     f42:	cf 90       	pop	r12
     f44:	bf 90       	pop	r11
     f46:	af 90       	pop	r10
     f48:	9f 90       	pop	r9
     f4a:	8f 90       	pop	r8
     f4c:	7f 90       	pop	r7
     f4e:	6f 90       	pop	r6
     f50:	08 95       	ret

00000f52 <Pid_Compute_Correction>:
#include "clamp.h"

/** Computes a PID based correction. 
 */
int16_t Pid_Compute_Correction( int16_t current_value, Pid_State_t *_p_state )
{
     f52:	0f 93       	push	r16
     f54:	1f 93       	push	r17
     f56:	df 93       	push	r29
     f58:	cf 93       	push	r28
     f5a:	00 d0       	rcall	.+0      	; 0xf5c <Pid_Compute_Correction+0xa>
     f5c:	cd b7       	in	r28, 0x3d	; 61
     f5e:	de b7       	in	r29, 0x3e	; 62
     f60:	8b 01       	movw	r16, r22
    int16_t correction;

    _p_state->error = _p_state->setpoint - current_value;
     f62:	fb 01       	movw	r30, r22
     f64:	40 81       	ld	r20, Z
     f66:	51 81       	ldd	r21, Z+1	; 0x01
     f68:	48 1b       	sub	r20, r24
     f6a:	59 0b       	sbc	r21, r25
     f6c:	53 83       	std	Z+3, r21	; 0x03
     f6e:	42 83       	std	Z+2, r20	; 0x02

    // Compute the derivative error
    _p_state->d_error = _p_state->prev_error - _p_state->error;
     f70:	64 81       	ldd	r22, Z+4	; 0x04
     f72:	75 81       	ldd	r23, Z+5	; 0x05
     f74:	64 1b       	sub	r22, r20
     f76:	75 0b       	sbc	r23, r21
     f78:	77 83       	std	Z+7, r23	; 0x07
     f7a:	66 83       	std	Z+6, r22	; 0x06

    // Update the previous error
    _p_state->prev_error = _p_state->error;
     f7c:	55 83       	std	Z+5, r21	; 0x05
     f7e:	44 83       	std	Z+4, r20	; 0x04

    correction = ( (_p_state->kp * _p_state->error) 
     f80:	84 85       	ldd	r24, Z+12	; 0x0c
     f82:	99 27       	eor	r25, r25
     f84:	87 fd       	sbrc	r24, 7
     f86:	90 95       	com	r25
     f88:	20 85       	ldd	r18, Z+8	; 0x08
     f8a:	31 85       	ldd	r19, Z+9	; 0x09
     f8c:	fc 01       	movw	r30, r24
     f8e:	e2 9f       	mul	r30, r18
     f90:	c0 01       	movw	r24, r0
     f92:	e3 9f       	mul	r30, r19
     f94:	90 0d       	add	r25, r0
     f96:	f2 9f       	mul	r31, r18
     f98:	90 0d       	add	r25, r0
     f9a:	11 24       	eor	r1, r1
     f9c:	f8 01       	movw	r30, r16
     f9e:	22 85       	ldd	r18, Z+10	; 0x0a
     fa0:	33 27       	eor	r19, r19
     fa2:	27 fd       	sbrc	r18, 7
     fa4:	30 95       	com	r19
     fa6:	f9 01       	movw	r30, r18
     fa8:	e4 9f       	mul	r30, r20
     faa:	90 01       	movw	r18, r0
     fac:	e5 9f       	mul	r30, r21
     fae:	30 0d       	add	r19, r0
     fb0:	f4 9f       	mul	r31, r20
     fb2:	30 0d       	add	r19, r0
     fb4:	11 24       	eor	r1, r1
     fb6:	82 0f       	add	r24, r18
     fb8:	93 1f       	adc	r25, r19
     fba:	f8 01       	movw	r30, r16
     fbc:	23 85       	ldd	r18, Z+11	; 0x0b
     fbe:	33 27       	eor	r19, r19
     fc0:	27 fd       	sbrc	r18, 7
     fc2:	30 95       	com	r19
     fc4:	a9 01       	movw	r20, r18
     fc6:	46 9f       	mul	r20, r22
     fc8:	90 01       	movw	r18, r0
     fca:	47 9f       	mul	r20, r23
     fcc:	30 0d       	add	r19, r0
     fce:	56 9f       	mul	r21, r22
     fd0:	30 0d       	add	r19, r0
     fd2:	11 24       	eor	r1, r1
     fd4:	65 85       	ldd	r22, Z+13	; 0x0d
     fd6:	77 27       	eor	r23, r23
     fd8:	67 fd       	sbrc	r22, 7
     fda:	70 95       	com	r23
     fdc:	82 1b       	sub	r24, r18
     fde:	93 0b       	sbc	r25, r19
     fe0:	0e 94 45 08 	call	0x108a	; 0x108a <__divmodhi4>
     fe4:	7a 83       	std	Y+2, r23	; 0x02
     fe6:	69 83       	std	Y+1, r22	; 0x01
                 - (_p_state->kd * _p_state->d_error) 
                 + (_p_state->ki * _p_state->i_error) )
                / _p_state->ko;

    Clamp_Abs_Value( &correction, _p_state->max_correction );
     fe8:	60 89       	ldd	r22, Z+16	; 0x10
     fea:	71 89       	ldd	r23, Z+17	; 0x11
     fec:	ce 01       	movw	r24, r28
     fee:	01 96       	adiw	r24, 0x01	; 1
     ff0:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <Clamp_Abs_Value>
    //if ( CLAMP_VALUE_NOT_CLAMPED == Clamp_Abs_Value( &correction, _p_state->max_correction ) )
    {
        // Compute the integral error
        _p_state->i_error += _p_state->error;
     ff4:	f8 01       	movw	r30, r16
     ff6:	80 85       	ldd	r24, Z+8	; 0x08
     ff8:	91 85       	ldd	r25, Z+9	; 0x09
     ffa:	22 81       	ldd	r18, Z+2	; 0x02
     ffc:	33 81       	ldd	r19, Z+3	; 0x03
     ffe:	82 0f       	add	r24, r18
    1000:	93 1f       	adc	r25, r19
    1002:	91 87       	std	Z+9, r25	; 0x09
    1004:	80 87       	std	Z+8, r24	; 0x08

        // Constrain the integral error
        Clamp_Abs_Value( &(_p_state->i_error), _p_state->max_i_error );
    1006:	66 85       	ldd	r22, Z+14	; 0x0e
    1008:	77 85       	ldd	r23, Z+15	; 0x0f
    100a:	c8 01       	movw	r24, r16
    100c:	08 96       	adiw	r24, 0x08	; 8
    100e:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <Clamp_Abs_Value>
    }

    return correction;
}
    1012:	89 81       	ldd	r24, Y+1	; 0x01
    1014:	9a 81       	ldd	r25, Y+2	; 0x02
    1016:	0f 90       	pop	r0
    1018:	0f 90       	pop	r0
    101a:	cf 91       	pop	r28
    101c:	df 91       	pop	r29
    101e:	1f 91       	pop	r17
    1020:	0f 91       	pop	r16
    1022:	08 95       	ret

00001024 <__mulsi3>:
    1024:	62 9f       	mul	r22, r18
    1026:	d0 01       	movw	r26, r0
    1028:	73 9f       	mul	r23, r19
    102a:	f0 01       	movw	r30, r0
    102c:	82 9f       	mul	r24, r18
    102e:	e0 0d       	add	r30, r0
    1030:	f1 1d       	adc	r31, r1
    1032:	64 9f       	mul	r22, r20
    1034:	e0 0d       	add	r30, r0
    1036:	f1 1d       	adc	r31, r1
    1038:	92 9f       	mul	r25, r18
    103a:	f0 0d       	add	r31, r0
    103c:	83 9f       	mul	r24, r19
    103e:	f0 0d       	add	r31, r0
    1040:	74 9f       	mul	r23, r20
    1042:	f0 0d       	add	r31, r0
    1044:	65 9f       	mul	r22, r21
    1046:	f0 0d       	add	r31, r0
    1048:	99 27       	eor	r25, r25
    104a:	72 9f       	mul	r23, r18
    104c:	b0 0d       	add	r27, r0
    104e:	e1 1d       	adc	r30, r1
    1050:	f9 1f       	adc	r31, r25
    1052:	63 9f       	mul	r22, r19
    1054:	b0 0d       	add	r27, r0
    1056:	e1 1d       	adc	r30, r1
    1058:	f9 1f       	adc	r31, r25
    105a:	bd 01       	movw	r22, r26
    105c:	cf 01       	movw	r24, r30
    105e:	11 24       	eor	r1, r1
    1060:	08 95       	ret

00001062 <__udivmodhi4>:
    1062:	aa 1b       	sub	r26, r26
    1064:	bb 1b       	sub	r27, r27
    1066:	51 e1       	ldi	r21, 0x11	; 17
    1068:	07 c0       	rjmp	.+14     	; 0x1078 <__udivmodhi4_ep>

0000106a <__udivmodhi4_loop>:
    106a:	aa 1f       	adc	r26, r26
    106c:	bb 1f       	adc	r27, r27
    106e:	a6 17       	cp	r26, r22
    1070:	b7 07       	cpc	r27, r23
    1072:	10 f0       	brcs	.+4      	; 0x1078 <__udivmodhi4_ep>
    1074:	a6 1b       	sub	r26, r22
    1076:	b7 0b       	sbc	r27, r23

00001078 <__udivmodhi4_ep>:
    1078:	88 1f       	adc	r24, r24
    107a:	99 1f       	adc	r25, r25
    107c:	5a 95       	dec	r21
    107e:	a9 f7       	brne	.-22     	; 0x106a <__udivmodhi4_loop>
    1080:	80 95       	com	r24
    1082:	90 95       	com	r25
    1084:	bc 01       	movw	r22, r24
    1086:	cd 01       	movw	r24, r26
    1088:	08 95       	ret

0000108a <__divmodhi4>:
    108a:	97 fb       	bst	r25, 7
    108c:	09 2e       	mov	r0, r25
    108e:	07 26       	eor	r0, r23
    1090:	0a d0       	rcall	.+20     	; 0x10a6 <__divmodhi4_neg1>
    1092:	77 fd       	sbrc	r23, 7
    1094:	04 d0       	rcall	.+8      	; 0x109e <__divmodhi4_neg2>
    1096:	e5 df       	rcall	.-54     	; 0x1062 <__udivmodhi4>
    1098:	06 d0       	rcall	.+12     	; 0x10a6 <__divmodhi4_neg1>
    109a:	00 20       	and	r0, r0
    109c:	1a f4       	brpl	.+6      	; 0x10a4 <__divmodhi4_exit>

0000109e <__divmodhi4_neg2>:
    109e:	70 95       	com	r23
    10a0:	61 95       	neg	r22
    10a2:	7f 4f       	sbci	r23, 0xFF	; 255

000010a4 <__divmodhi4_exit>:
    10a4:	08 95       	ret

000010a6 <__divmodhi4_neg1>:
    10a6:	f6 f7       	brtc	.-4      	; 0x10a4 <__divmodhi4_exit>
    10a8:	90 95       	com	r25
    10aa:	81 95       	neg	r24
    10ac:	9f 4f       	sbci	r25, 0xFF	; 255
    10ae:	08 95       	ret

000010b0 <__divmodsi4>:
    10b0:	97 fb       	bst	r25, 7
    10b2:	09 2e       	mov	r0, r25
    10b4:	05 26       	eor	r0, r21
    10b6:	0e d0       	rcall	.+28     	; 0x10d4 <__divmodsi4_neg1>
    10b8:	57 fd       	sbrc	r21, 7
    10ba:	04 d0       	rcall	.+8      	; 0x10c4 <__divmodsi4_neg2>
    10bc:	14 d0       	rcall	.+40     	; 0x10e6 <__udivmodsi4>
    10be:	0a d0       	rcall	.+20     	; 0x10d4 <__divmodsi4_neg1>
    10c0:	00 1c       	adc	r0, r0
    10c2:	38 f4       	brcc	.+14     	; 0x10d2 <__divmodsi4_exit>

000010c4 <__divmodsi4_neg2>:
    10c4:	50 95       	com	r21
    10c6:	40 95       	com	r20
    10c8:	30 95       	com	r19
    10ca:	21 95       	neg	r18
    10cc:	3f 4f       	sbci	r19, 0xFF	; 255
    10ce:	4f 4f       	sbci	r20, 0xFF	; 255
    10d0:	5f 4f       	sbci	r21, 0xFF	; 255

000010d2 <__divmodsi4_exit>:
    10d2:	08 95       	ret

000010d4 <__divmodsi4_neg1>:
    10d4:	f6 f7       	brtc	.-4      	; 0x10d2 <__divmodsi4_exit>
    10d6:	90 95       	com	r25
    10d8:	80 95       	com	r24
    10da:	70 95       	com	r23
    10dc:	61 95       	neg	r22
    10de:	7f 4f       	sbci	r23, 0xFF	; 255
    10e0:	8f 4f       	sbci	r24, 0xFF	; 255
    10e2:	9f 4f       	sbci	r25, 0xFF	; 255
    10e4:	08 95       	ret

000010e6 <__udivmodsi4>:
    10e6:	a1 e2       	ldi	r26, 0x21	; 33
    10e8:	1a 2e       	mov	r1, r26
    10ea:	aa 1b       	sub	r26, r26
    10ec:	bb 1b       	sub	r27, r27
    10ee:	fd 01       	movw	r30, r26
    10f0:	0d c0       	rjmp	.+26     	; 0x110c <__udivmodsi4_ep>

000010f2 <__udivmodsi4_loop>:
    10f2:	aa 1f       	adc	r26, r26
    10f4:	bb 1f       	adc	r27, r27
    10f6:	ee 1f       	adc	r30, r30
    10f8:	ff 1f       	adc	r31, r31
    10fa:	a2 17       	cp	r26, r18
    10fc:	b3 07       	cpc	r27, r19
    10fe:	e4 07       	cpc	r30, r20
    1100:	f5 07       	cpc	r31, r21
    1102:	20 f0       	brcs	.+8      	; 0x110c <__udivmodsi4_ep>
    1104:	a2 1b       	sub	r26, r18
    1106:	b3 0b       	sbc	r27, r19
    1108:	e4 0b       	sbc	r30, r20
    110a:	f5 0b       	sbc	r31, r21

0000110c <__udivmodsi4_ep>:
    110c:	66 1f       	adc	r22, r22
    110e:	77 1f       	adc	r23, r23
    1110:	88 1f       	adc	r24, r24
    1112:	99 1f       	adc	r25, r25
    1114:	1a 94       	dec	r1
    1116:	69 f7       	brne	.-38     	; 0x10f2 <__udivmodsi4_loop>
    1118:	60 95       	com	r22
    111a:	70 95       	com	r23
    111c:	80 95       	com	r24
    111e:	90 95       	com	r25
    1120:	9b 01       	movw	r18, r22
    1122:	ac 01       	movw	r20, r24
    1124:	bd 01       	movw	r22, r26
    1126:	cf 01       	movw	r24, r30
    1128:	08 95       	ret

0000112a <sprintf>:
    112a:	ae e0       	ldi	r26, 0x0E	; 14
    112c:	b0 e0       	ldi	r27, 0x00	; 0
    112e:	eb e9       	ldi	r30, 0x9B	; 155
    1130:	f8 e0       	ldi	r31, 0x08	; 8
    1132:	0c 94 44 0b 	jmp	0x1688	; 0x1688 <__prologue_saves__+0x1c>
    1136:	0d 89       	ldd	r16, Y+21	; 0x15
    1138:	1e 89       	ldd	r17, Y+22	; 0x16
    113a:	86 e0       	ldi	r24, 0x06	; 6
    113c:	8c 83       	std	Y+4, r24	; 0x04
    113e:	1a 83       	std	Y+2, r17	; 0x02
    1140:	09 83       	std	Y+1, r16	; 0x01
    1142:	8f ef       	ldi	r24, 0xFF	; 255
    1144:	9f e7       	ldi	r25, 0x7F	; 127
    1146:	9e 83       	std	Y+6, r25	; 0x06
    1148:	8d 83       	std	Y+5, r24	; 0x05
    114a:	9e 01       	movw	r18, r28
    114c:	27 5e       	subi	r18, 0xE7	; 231
    114e:	3f 4f       	sbci	r19, 0xFF	; 255
    1150:	ce 01       	movw	r24, r28
    1152:	01 96       	adiw	r24, 0x01	; 1
    1154:	6f 89       	ldd	r22, Y+23	; 0x17
    1156:	78 8d       	ldd	r23, Y+24	; 0x18
    1158:	a9 01       	movw	r20, r18
    115a:	0e 94 b9 08 	call	0x1172	; 0x1172 <vfprintf>
    115e:	2f 81       	ldd	r18, Y+7	; 0x07
    1160:	38 85       	ldd	r19, Y+8	; 0x08
    1162:	02 0f       	add	r16, r18
    1164:	13 1f       	adc	r17, r19
    1166:	f8 01       	movw	r30, r16
    1168:	10 82       	st	Z, r1
    116a:	2e 96       	adiw	r28, 0x0e	; 14
    116c:	e4 e0       	ldi	r30, 0x04	; 4
    116e:	0c 94 60 0b 	jmp	0x16c0	; 0x16c0 <__epilogue_restores__+0x1c>

00001172 <vfprintf>:
    1172:	ab e0       	ldi	r26, 0x0B	; 11
    1174:	b0 e0       	ldi	r27, 0x00	; 0
    1176:	ef eb       	ldi	r30, 0xBF	; 191
    1178:	f8 e0       	ldi	r31, 0x08	; 8
    117a:	0c 94 36 0b 	jmp	0x166c	; 0x166c <__prologue_saves__>
    117e:	3c 01       	movw	r6, r24
    1180:	2b 01       	movw	r4, r22
    1182:	5a 01       	movw	r10, r20
    1184:	fc 01       	movw	r30, r24
    1186:	17 82       	std	Z+7, r1	; 0x07
    1188:	16 82       	std	Z+6, r1	; 0x06
    118a:	83 81       	ldd	r24, Z+3	; 0x03
    118c:	81 fd       	sbrc	r24, 1
    118e:	03 c0       	rjmp	.+6      	; 0x1196 <vfprintf+0x24>
    1190:	6f ef       	ldi	r22, 0xFF	; 255
    1192:	7f ef       	ldi	r23, 0xFF	; 255
    1194:	c6 c1       	rjmp	.+908    	; 0x1522 <vfprintf+0x3b0>
    1196:	9a e0       	ldi	r25, 0x0A	; 10
    1198:	89 2e       	mov	r8, r25
    119a:	1e 01       	movw	r2, r28
    119c:	08 94       	sec
    119e:	21 1c       	adc	r2, r1
    11a0:	31 1c       	adc	r3, r1
    11a2:	f3 01       	movw	r30, r6
    11a4:	23 81       	ldd	r18, Z+3	; 0x03
    11a6:	f2 01       	movw	r30, r4
    11a8:	23 fd       	sbrc	r18, 3
    11aa:	85 91       	lpm	r24, Z+
    11ac:	23 ff       	sbrs	r18, 3
    11ae:	81 91       	ld	r24, Z+
    11b0:	2f 01       	movw	r4, r30
    11b2:	88 23       	and	r24, r24
    11b4:	09 f4       	brne	.+2      	; 0x11b8 <vfprintf+0x46>
    11b6:	b2 c1       	rjmp	.+868    	; 0x151c <vfprintf+0x3aa>
    11b8:	85 32       	cpi	r24, 0x25	; 37
    11ba:	39 f4       	brne	.+14     	; 0x11ca <vfprintf+0x58>
    11bc:	23 fd       	sbrc	r18, 3
    11be:	85 91       	lpm	r24, Z+
    11c0:	23 ff       	sbrs	r18, 3
    11c2:	81 91       	ld	r24, Z+
    11c4:	2f 01       	movw	r4, r30
    11c6:	85 32       	cpi	r24, 0x25	; 37
    11c8:	29 f4       	brne	.+10     	; 0x11d4 <vfprintf+0x62>
    11ca:	90 e0       	ldi	r25, 0x00	; 0
    11cc:	b3 01       	movw	r22, r6
    11ce:	0e 94 ac 0a 	call	0x1558	; 0x1558 <fputc>
    11d2:	e7 cf       	rjmp	.-50     	; 0x11a2 <vfprintf+0x30>
    11d4:	98 2f       	mov	r25, r24
    11d6:	ff 24       	eor	r15, r15
    11d8:	ee 24       	eor	r14, r14
    11da:	99 24       	eor	r9, r9
    11dc:	ff e1       	ldi	r31, 0x1F	; 31
    11de:	ff 15       	cp	r31, r15
    11e0:	d0 f0       	brcs	.+52     	; 0x1216 <vfprintf+0xa4>
    11e2:	9b 32       	cpi	r25, 0x2B	; 43
    11e4:	69 f0       	breq	.+26     	; 0x1200 <vfprintf+0x8e>
    11e6:	9c 32       	cpi	r25, 0x2C	; 44
    11e8:	28 f4       	brcc	.+10     	; 0x11f4 <vfprintf+0x82>
    11ea:	90 32       	cpi	r25, 0x20	; 32
    11ec:	59 f0       	breq	.+22     	; 0x1204 <vfprintf+0x92>
    11ee:	93 32       	cpi	r25, 0x23	; 35
    11f0:	91 f4       	brne	.+36     	; 0x1216 <vfprintf+0xa4>
    11f2:	0e c0       	rjmp	.+28     	; 0x1210 <vfprintf+0x9e>
    11f4:	9d 32       	cpi	r25, 0x2D	; 45
    11f6:	49 f0       	breq	.+18     	; 0x120a <vfprintf+0x98>
    11f8:	90 33       	cpi	r25, 0x30	; 48
    11fa:	69 f4       	brne	.+26     	; 0x1216 <vfprintf+0xa4>
    11fc:	41 e0       	ldi	r20, 0x01	; 1
    11fe:	24 c0       	rjmp	.+72     	; 0x1248 <vfprintf+0xd6>
    1200:	52 e0       	ldi	r21, 0x02	; 2
    1202:	f5 2a       	or	r15, r21
    1204:	84 e0       	ldi	r24, 0x04	; 4
    1206:	f8 2a       	or	r15, r24
    1208:	28 c0       	rjmp	.+80     	; 0x125a <vfprintf+0xe8>
    120a:	98 e0       	ldi	r25, 0x08	; 8
    120c:	f9 2a       	or	r15, r25
    120e:	25 c0       	rjmp	.+74     	; 0x125a <vfprintf+0xe8>
    1210:	e0 e1       	ldi	r30, 0x10	; 16
    1212:	fe 2a       	or	r15, r30
    1214:	22 c0       	rjmp	.+68     	; 0x125a <vfprintf+0xe8>
    1216:	f7 fc       	sbrc	r15, 7
    1218:	29 c0       	rjmp	.+82     	; 0x126c <vfprintf+0xfa>
    121a:	89 2f       	mov	r24, r25
    121c:	80 53       	subi	r24, 0x30	; 48
    121e:	8a 30       	cpi	r24, 0x0A	; 10
    1220:	70 f4       	brcc	.+28     	; 0x123e <vfprintf+0xcc>
    1222:	f6 fe       	sbrs	r15, 6
    1224:	05 c0       	rjmp	.+10     	; 0x1230 <vfprintf+0xbe>
    1226:	98 9c       	mul	r9, r8
    1228:	90 2c       	mov	r9, r0
    122a:	11 24       	eor	r1, r1
    122c:	98 0e       	add	r9, r24
    122e:	15 c0       	rjmp	.+42     	; 0x125a <vfprintf+0xe8>
    1230:	e8 9c       	mul	r14, r8
    1232:	e0 2c       	mov	r14, r0
    1234:	11 24       	eor	r1, r1
    1236:	e8 0e       	add	r14, r24
    1238:	f0 e2       	ldi	r31, 0x20	; 32
    123a:	ff 2a       	or	r15, r31
    123c:	0e c0       	rjmp	.+28     	; 0x125a <vfprintf+0xe8>
    123e:	9e 32       	cpi	r25, 0x2E	; 46
    1240:	29 f4       	brne	.+10     	; 0x124c <vfprintf+0xda>
    1242:	f6 fc       	sbrc	r15, 6
    1244:	6b c1       	rjmp	.+726    	; 0x151c <vfprintf+0x3aa>
    1246:	40 e4       	ldi	r20, 0x40	; 64
    1248:	f4 2a       	or	r15, r20
    124a:	07 c0       	rjmp	.+14     	; 0x125a <vfprintf+0xe8>
    124c:	9c 36       	cpi	r25, 0x6C	; 108
    124e:	19 f4       	brne	.+6      	; 0x1256 <vfprintf+0xe4>
    1250:	50 e8       	ldi	r21, 0x80	; 128
    1252:	f5 2a       	or	r15, r21
    1254:	02 c0       	rjmp	.+4      	; 0x125a <vfprintf+0xe8>
    1256:	98 36       	cpi	r25, 0x68	; 104
    1258:	49 f4       	brne	.+18     	; 0x126c <vfprintf+0xfa>
    125a:	f2 01       	movw	r30, r4
    125c:	23 fd       	sbrc	r18, 3
    125e:	95 91       	lpm	r25, Z+
    1260:	23 ff       	sbrs	r18, 3
    1262:	91 91       	ld	r25, Z+
    1264:	2f 01       	movw	r4, r30
    1266:	99 23       	and	r25, r25
    1268:	09 f0       	breq	.+2      	; 0x126c <vfprintf+0xfa>
    126a:	b8 cf       	rjmp	.-144    	; 0x11dc <vfprintf+0x6a>
    126c:	89 2f       	mov	r24, r25
    126e:	85 54       	subi	r24, 0x45	; 69
    1270:	83 30       	cpi	r24, 0x03	; 3
    1272:	18 f0       	brcs	.+6      	; 0x127a <vfprintf+0x108>
    1274:	80 52       	subi	r24, 0x20	; 32
    1276:	83 30       	cpi	r24, 0x03	; 3
    1278:	38 f4       	brcc	.+14     	; 0x1288 <vfprintf+0x116>
    127a:	44 e0       	ldi	r20, 0x04	; 4
    127c:	50 e0       	ldi	r21, 0x00	; 0
    127e:	a4 0e       	add	r10, r20
    1280:	b5 1e       	adc	r11, r21
    1282:	5f e3       	ldi	r21, 0x3F	; 63
    1284:	59 83       	std	Y+1, r21	; 0x01
    1286:	0f c0       	rjmp	.+30     	; 0x12a6 <vfprintf+0x134>
    1288:	93 36       	cpi	r25, 0x63	; 99
    128a:	31 f0       	breq	.+12     	; 0x1298 <vfprintf+0x126>
    128c:	93 37       	cpi	r25, 0x73	; 115
    128e:	79 f0       	breq	.+30     	; 0x12ae <vfprintf+0x13c>
    1290:	93 35       	cpi	r25, 0x53	; 83
    1292:	09 f0       	breq	.+2      	; 0x1296 <vfprintf+0x124>
    1294:	56 c0       	rjmp	.+172    	; 0x1342 <vfprintf+0x1d0>
    1296:	20 c0       	rjmp	.+64     	; 0x12d8 <vfprintf+0x166>
    1298:	f5 01       	movw	r30, r10
    129a:	80 81       	ld	r24, Z
    129c:	89 83       	std	Y+1, r24	; 0x01
    129e:	42 e0       	ldi	r20, 0x02	; 2
    12a0:	50 e0       	ldi	r21, 0x00	; 0
    12a2:	a4 0e       	add	r10, r20
    12a4:	b5 1e       	adc	r11, r21
    12a6:	61 01       	movw	r12, r2
    12a8:	01 e0       	ldi	r16, 0x01	; 1
    12aa:	10 e0       	ldi	r17, 0x00	; 0
    12ac:	12 c0       	rjmp	.+36     	; 0x12d2 <vfprintf+0x160>
    12ae:	f5 01       	movw	r30, r10
    12b0:	c0 80       	ld	r12, Z
    12b2:	d1 80       	ldd	r13, Z+1	; 0x01
    12b4:	f6 fc       	sbrc	r15, 6
    12b6:	03 c0       	rjmp	.+6      	; 0x12be <vfprintf+0x14c>
    12b8:	6f ef       	ldi	r22, 0xFF	; 255
    12ba:	7f ef       	ldi	r23, 0xFF	; 255
    12bc:	02 c0       	rjmp	.+4      	; 0x12c2 <vfprintf+0x150>
    12be:	69 2d       	mov	r22, r9
    12c0:	70 e0       	ldi	r23, 0x00	; 0
    12c2:	42 e0       	ldi	r20, 0x02	; 2
    12c4:	50 e0       	ldi	r21, 0x00	; 0
    12c6:	a4 0e       	add	r10, r20
    12c8:	b5 1e       	adc	r11, r21
    12ca:	c6 01       	movw	r24, r12
    12cc:	0e 94 a1 0a 	call	0x1542	; 0x1542 <strnlen>
    12d0:	8c 01       	movw	r16, r24
    12d2:	5f e7       	ldi	r21, 0x7F	; 127
    12d4:	f5 22       	and	r15, r21
    12d6:	14 c0       	rjmp	.+40     	; 0x1300 <vfprintf+0x18e>
    12d8:	f5 01       	movw	r30, r10
    12da:	c0 80       	ld	r12, Z
    12dc:	d1 80       	ldd	r13, Z+1	; 0x01
    12de:	f6 fc       	sbrc	r15, 6
    12e0:	03 c0       	rjmp	.+6      	; 0x12e8 <vfprintf+0x176>
    12e2:	6f ef       	ldi	r22, 0xFF	; 255
    12e4:	7f ef       	ldi	r23, 0xFF	; 255
    12e6:	02 c0       	rjmp	.+4      	; 0x12ec <vfprintf+0x17a>
    12e8:	69 2d       	mov	r22, r9
    12ea:	70 e0       	ldi	r23, 0x00	; 0
    12ec:	42 e0       	ldi	r20, 0x02	; 2
    12ee:	50 e0       	ldi	r21, 0x00	; 0
    12f0:	a4 0e       	add	r10, r20
    12f2:	b5 1e       	adc	r11, r21
    12f4:	c6 01       	movw	r24, r12
    12f6:	0e 94 96 0a 	call	0x152c	; 0x152c <strnlen_P>
    12fa:	8c 01       	movw	r16, r24
    12fc:	50 e8       	ldi	r21, 0x80	; 128
    12fe:	f5 2a       	or	r15, r21
    1300:	f3 fe       	sbrs	r15, 3
    1302:	07 c0       	rjmp	.+14     	; 0x1312 <vfprintf+0x1a0>
    1304:	1a c0       	rjmp	.+52     	; 0x133a <vfprintf+0x1c8>
    1306:	80 e2       	ldi	r24, 0x20	; 32
    1308:	90 e0       	ldi	r25, 0x00	; 0
    130a:	b3 01       	movw	r22, r6
    130c:	0e 94 ac 0a 	call	0x1558	; 0x1558 <fputc>
    1310:	ea 94       	dec	r14
    1312:	8e 2d       	mov	r24, r14
    1314:	90 e0       	ldi	r25, 0x00	; 0
    1316:	08 17       	cp	r16, r24
    1318:	19 07       	cpc	r17, r25
    131a:	a8 f3       	brcs	.-22     	; 0x1306 <vfprintf+0x194>
    131c:	0e c0       	rjmp	.+28     	; 0x133a <vfprintf+0x1c8>
    131e:	f6 01       	movw	r30, r12
    1320:	f7 fc       	sbrc	r15, 7
    1322:	85 91       	lpm	r24, Z+
    1324:	f7 fe       	sbrs	r15, 7
    1326:	81 91       	ld	r24, Z+
    1328:	6f 01       	movw	r12, r30
    132a:	90 e0       	ldi	r25, 0x00	; 0
    132c:	b3 01       	movw	r22, r6
    132e:	0e 94 ac 0a 	call	0x1558	; 0x1558 <fputc>
    1332:	e1 10       	cpse	r14, r1
    1334:	ea 94       	dec	r14
    1336:	01 50       	subi	r16, 0x01	; 1
    1338:	10 40       	sbci	r17, 0x00	; 0
    133a:	01 15       	cp	r16, r1
    133c:	11 05       	cpc	r17, r1
    133e:	79 f7       	brne	.-34     	; 0x131e <vfprintf+0x1ac>
    1340:	ea c0       	rjmp	.+468    	; 0x1516 <vfprintf+0x3a4>
    1342:	94 36       	cpi	r25, 0x64	; 100
    1344:	11 f0       	breq	.+4      	; 0x134a <vfprintf+0x1d8>
    1346:	99 36       	cpi	r25, 0x69	; 105
    1348:	69 f5       	brne	.+90     	; 0x13a4 <vfprintf+0x232>
    134a:	f7 fe       	sbrs	r15, 7
    134c:	08 c0       	rjmp	.+16     	; 0x135e <vfprintf+0x1ec>
    134e:	f5 01       	movw	r30, r10
    1350:	20 81       	ld	r18, Z
    1352:	31 81       	ldd	r19, Z+1	; 0x01
    1354:	42 81       	ldd	r20, Z+2	; 0x02
    1356:	53 81       	ldd	r21, Z+3	; 0x03
    1358:	84 e0       	ldi	r24, 0x04	; 4
    135a:	90 e0       	ldi	r25, 0x00	; 0
    135c:	0a c0       	rjmp	.+20     	; 0x1372 <vfprintf+0x200>
    135e:	f5 01       	movw	r30, r10
    1360:	80 81       	ld	r24, Z
    1362:	91 81       	ldd	r25, Z+1	; 0x01
    1364:	9c 01       	movw	r18, r24
    1366:	44 27       	eor	r20, r20
    1368:	37 fd       	sbrc	r19, 7
    136a:	40 95       	com	r20
    136c:	54 2f       	mov	r21, r20
    136e:	82 e0       	ldi	r24, 0x02	; 2
    1370:	90 e0       	ldi	r25, 0x00	; 0
    1372:	a8 0e       	add	r10, r24
    1374:	b9 1e       	adc	r11, r25
    1376:	9f e6       	ldi	r25, 0x6F	; 111
    1378:	f9 22       	and	r15, r25
    137a:	57 ff       	sbrs	r21, 7
    137c:	09 c0       	rjmp	.+18     	; 0x1390 <vfprintf+0x21e>
    137e:	50 95       	com	r21
    1380:	40 95       	com	r20
    1382:	30 95       	com	r19
    1384:	21 95       	neg	r18
    1386:	3f 4f       	sbci	r19, 0xFF	; 255
    1388:	4f 4f       	sbci	r20, 0xFF	; 255
    138a:	5f 4f       	sbci	r21, 0xFF	; 255
    138c:	e0 e8       	ldi	r30, 0x80	; 128
    138e:	fe 2a       	or	r15, r30
    1390:	ca 01       	movw	r24, r20
    1392:	b9 01       	movw	r22, r18
    1394:	a1 01       	movw	r20, r2
    1396:	2a e0       	ldi	r18, 0x0A	; 10
    1398:	30 e0       	ldi	r19, 0x00	; 0
    139a:	0e 94 d8 0a 	call	0x15b0	; 0x15b0 <__ultoa_invert>
    139e:	d8 2e       	mov	r13, r24
    13a0:	d2 18       	sub	r13, r2
    13a2:	40 c0       	rjmp	.+128    	; 0x1424 <vfprintf+0x2b2>
    13a4:	95 37       	cpi	r25, 0x75	; 117
    13a6:	29 f4       	brne	.+10     	; 0x13b2 <vfprintf+0x240>
    13a8:	1f 2d       	mov	r17, r15
    13aa:	1f 7e       	andi	r17, 0xEF	; 239
    13ac:	2a e0       	ldi	r18, 0x0A	; 10
    13ae:	30 e0       	ldi	r19, 0x00	; 0
    13b0:	1d c0       	rjmp	.+58     	; 0x13ec <vfprintf+0x27a>
    13b2:	1f 2d       	mov	r17, r15
    13b4:	19 7f       	andi	r17, 0xF9	; 249
    13b6:	9f 36       	cpi	r25, 0x6F	; 111
    13b8:	61 f0       	breq	.+24     	; 0x13d2 <vfprintf+0x260>
    13ba:	90 37       	cpi	r25, 0x70	; 112
    13bc:	20 f4       	brcc	.+8      	; 0x13c6 <vfprintf+0x254>
    13be:	98 35       	cpi	r25, 0x58	; 88
    13c0:	09 f0       	breq	.+2      	; 0x13c4 <vfprintf+0x252>
    13c2:	ac c0       	rjmp	.+344    	; 0x151c <vfprintf+0x3aa>
    13c4:	0f c0       	rjmp	.+30     	; 0x13e4 <vfprintf+0x272>
    13c6:	90 37       	cpi	r25, 0x70	; 112
    13c8:	39 f0       	breq	.+14     	; 0x13d8 <vfprintf+0x266>
    13ca:	98 37       	cpi	r25, 0x78	; 120
    13cc:	09 f0       	breq	.+2      	; 0x13d0 <vfprintf+0x25e>
    13ce:	a6 c0       	rjmp	.+332    	; 0x151c <vfprintf+0x3aa>
    13d0:	04 c0       	rjmp	.+8      	; 0x13da <vfprintf+0x268>
    13d2:	28 e0       	ldi	r18, 0x08	; 8
    13d4:	30 e0       	ldi	r19, 0x00	; 0
    13d6:	0a c0       	rjmp	.+20     	; 0x13ec <vfprintf+0x27a>
    13d8:	10 61       	ori	r17, 0x10	; 16
    13da:	14 fd       	sbrc	r17, 4
    13dc:	14 60       	ori	r17, 0x04	; 4
    13de:	20 e1       	ldi	r18, 0x10	; 16
    13e0:	30 e0       	ldi	r19, 0x00	; 0
    13e2:	04 c0       	rjmp	.+8      	; 0x13ec <vfprintf+0x27a>
    13e4:	14 fd       	sbrc	r17, 4
    13e6:	16 60       	ori	r17, 0x06	; 6
    13e8:	20 e1       	ldi	r18, 0x10	; 16
    13ea:	32 e0       	ldi	r19, 0x02	; 2
    13ec:	17 ff       	sbrs	r17, 7
    13ee:	08 c0       	rjmp	.+16     	; 0x1400 <vfprintf+0x28e>
    13f0:	f5 01       	movw	r30, r10
    13f2:	60 81       	ld	r22, Z
    13f4:	71 81       	ldd	r23, Z+1	; 0x01
    13f6:	82 81       	ldd	r24, Z+2	; 0x02
    13f8:	93 81       	ldd	r25, Z+3	; 0x03
    13fa:	44 e0       	ldi	r20, 0x04	; 4
    13fc:	50 e0       	ldi	r21, 0x00	; 0
    13fe:	08 c0       	rjmp	.+16     	; 0x1410 <vfprintf+0x29e>
    1400:	f5 01       	movw	r30, r10
    1402:	80 81       	ld	r24, Z
    1404:	91 81       	ldd	r25, Z+1	; 0x01
    1406:	bc 01       	movw	r22, r24
    1408:	80 e0       	ldi	r24, 0x00	; 0
    140a:	90 e0       	ldi	r25, 0x00	; 0
    140c:	42 e0       	ldi	r20, 0x02	; 2
    140e:	50 e0       	ldi	r21, 0x00	; 0
    1410:	a4 0e       	add	r10, r20
    1412:	b5 1e       	adc	r11, r21
    1414:	a1 01       	movw	r20, r2
    1416:	0e 94 d8 0a 	call	0x15b0	; 0x15b0 <__ultoa_invert>
    141a:	d8 2e       	mov	r13, r24
    141c:	d2 18       	sub	r13, r2
    141e:	8f e7       	ldi	r24, 0x7F	; 127
    1420:	f8 2e       	mov	r15, r24
    1422:	f1 22       	and	r15, r17
    1424:	f6 fe       	sbrs	r15, 6
    1426:	0b c0       	rjmp	.+22     	; 0x143e <vfprintf+0x2cc>
    1428:	5e ef       	ldi	r21, 0xFE	; 254
    142a:	f5 22       	and	r15, r21
    142c:	d9 14       	cp	r13, r9
    142e:	38 f4       	brcc	.+14     	; 0x143e <vfprintf+0x2cc>
    1430:	f4 fe       	sbrs	r15, 4
    1432:	07 c0       	rjmp	.+14     	; 0x1442 <vfprintf+0x2d0>
    1434:	f2 fc       	sbrc	r15, 2
    1436:	05 c0       	rjmp	.+10     	; 0x1442 <vfprintf+0x2d0>
    1438:	8f ee       	ldi	r24, 0xEF	; 239
    143a:	f8 22       	and	r15, r24
    143c:	02 c0       	rjmp	.+4      	; 0x1442 <vfprintf+0x2d0>
    143e:	1d 2d       	mov	r17, r13
    1440:	01 c0       	rjmp	.+2      	; 0x1444 <vfprintf+0x2d2>
    1442:	19 2d       	mov	r17, r9
    1444:	f4 fe       	sbrs	r15, 4
    1446:	0d c0       	rjmp	.+26     	; 0x1462 <vfprintf+0x2f0>
    1448:	fe 01       	movw	r30, r28
    144a:	ed 0d       	add	r30, r13
    144c:	f1 1d       	adc	r31, r1
    144e:	80 81       	ld	r24, Z
    1450:	80 33       	cpi	r24, 0x30	; 48
    1452:	19 f4       	brne	.+6      	; 0x145a <vfprintf+0x2e8>
    1454:	99 ee       	ldi	r25, 0xE9	; 233
    1456:	f9 22       	and	r15, r25
    1458:	08 c0       	rjmp	.+16     	; 0x146a <vfprintf+0x2f8>
    145a:	1f 5f       	subi	r17, 0xFF	; 255
    145c:	f2 fe       	sbrs	r15, 2
    145e:	05 c0       	rjmp	.+10     	; 0x146a <vfprintf+0x2f8>
    1460:	03 c0       	rjmp	.+6      	; 0x1468 <vfprintf+0x2f6>
    1462:	8f 2d       	mov	r24, r15
    1464:	86 78       	andi	r24, 0x86	; 134
    1466:	09 f0       	breq	.+2      	; 0x146a <vfprintf+0x2f8>
    1468:	1f 5f       	subi	r17, 0xFF	; 255
    146a:	0f 2d       	mov	r16, r15
    146c:	f3 fc       	sbrc	r15, 3
    146e:	14 c0       	rjmp	.+40     	; 0x1498 <vfprintf+0x326>
    1470:	f0 fe       	sbrs	r15, 0
    1472:	0f c0       	rjmp	.+30     	; 0x1492 <vfprintf+0x320>
    1474:	1e 15       	cp	r17, r14
    1476:	10 f0       	brcs	.+4      	; 0x147c <vfprintf+0x30a>
    1478:	9d 2c       	mov	r9, r13
    147a:	0b c0       	rjmp	.+22     	; 0x1492 <vfprintf+0x320>
    147c:	9d 2c       	mov	r9, r13
    147e:	9e 0c       	add	r9, r14
    1480:	91 1a       	sub	r9, r17
    1482:	1e 2d       	mov	r17, r14
    1484:	06 c0       	rjmp	.+12     	; 0x1492 <vfprintf+0x320>
    1486:	80 e2       	ldi	r24, 0x20	; 32
    1488:	90 e0       	ldi	r25, 0x00	; 0
    148a:	b3 01       	movw	r22, r6
    148c:	0e 94 ac 0a 	call	0x1558	; 0x1558 <fputc>
    1490:	1f 5f       	subi	r17, 0xFF	; 255
    1492:	1e 15       	cp	r17, r14
    1494:	c0 f3       	brcs	.-16     	; 0x1486 <vfprintf+0x314>
    1496:	04 c0       	rjmp	.+8      	; 0x14a0 <vfprintf+0x32e>
    1498:	1e 15       	cp	r17, r14
    149a:	10 f4       	brcc	.+4      	; 0x14a0 <vfprintf+0x32e>
    149c:	e1 1a       	sub	r14, r17
    149e:	01 c0       	rjmp	.+2      	; 0x14a2 <vfprintf+0x330>
    14a0:	ee 24       	eor	r14, r14
    14a2:	04 ff       	sbrs	r16, 4
    14a4:	0f c0       	rjmp	.+30     	; 0x14c4 <vfprintf+0x352>
    14a6:	80 e3       	ldi	r24, 0x30	; 48
    14a8:	90 e0       	ldi	r25, 0x00	; 0
    14aa:	b3 01       	movw	r22, r6
    14ac:	0e 94 ac 0a 	call	0x1558	; 0x1558 <fputc>
    14b0:	02 ff       	sbrs	r16, 2
    14b2:	1d c0       	rjmp	.+58     	; 0x14ee <vfprintf+0x37c>
    14b4:	01 fd       	sbrc	r16, 1
    14b6:	03 c0       	rjmp	.+6      	; 0x14be <vfprintf+0x34c>
    14b8:	88 e7       	ldi	r24, 0x78	; 120
    14ba:	90 e0       	ldi	r25, 0x00	; 0
    14bc:	0e c0       	rjmp	.+28     	; 0x14da <vfprintf+0x368>
    14be:	88 e5       	ldi	r24, 0x58	; 88
    14c0:	90 e0       	ldi	r25, 0x00	; 0
    14c2:	0b c0       	rjmp	.+22     	; 0x14da <vfprintf+0x368>
    14c4:	80 2f       	mov	r24, r16
    14c6:	86 78       	andi	r24, 0x86	; 134
    14c8:	91 f0       	breq	.+36     	; 0x14ee <vfprintf+0x37c>
    14ca:	01 ff       	sbrs	r16, 1
    14cc:	02 c0       	rjmp	.+4      	; 0x14d2 <vfprintf+0x360>
    14ce:	8b e2       	ldi	r24, 0x2B	; 43
    14d0:	01 c0       	rjmp	.+2      	; 0x14d4 <vfprintf+0x362>
    14d2:	80 e2       	ldi	r24, 0x20	; 32
    14d4:	f7 fc       	sbrc	r15, 7
    14d6:	8d e2       	ldi	r24, 0x2D	; 45
    14d8:	90 e0       	ldi	r25, 0x00	; 0
    14da:	b3 01       	movw	r22, r6
    14dc:	0e 94 ac 0a 	call	0x1558	; 0x1558 <fputc>
    14e0:	06 c0       	rjmp	.+12     	; 0x14ee <vfprintf+0x37c>
    14e2:	80 e3       	ldi	r24, 0x30	; 48
    14e4:	90 e0       	ldi	r25, 0x00	; 0
    14e6:	b3 01       	movw	r22, r6
    14e8:	0e 94 ac 0a 	call	0x1558	; 0x1558 <fputc>
    14ec:	9a 94       	dec	r9
    14ee:	d9 14       	cp	r13, r9
    14f0:	c0 f3       	brcs	.-16     	; 0x14e2 <vfprintf+0x370>
    14f2:	da 94       	dec	r13
    14f4:	f1 01       	movw	r30, r2
    14f6:	ed 0d       	add	r30, r13
    14f8:	f1 1d       	adc	r31, r1
    14fa:	80 81       	ld	r24, Z
    14fc:	90 e0       	ldi	r25, 0x00	; 0
    14fe:	b3 01       	movw	r22, r6
    1500:	0e 94 ac 0a 	call	0x1558	; 0x1558 <fputc>
    1504:	dd 20       	and	r13, r13
    1506:	a9 f7       	brne	.-22     	; 0x14f2 <vfprintf+0x380>
    1508:	06 c0       	rjmp	.+12     	; 0x1516 <vfprintf+0x3a4>
    150a:	80 e2       	ldi	r24, 0x20	; 32
    150c:	90 e0       	ldi	r25, 0x00	; 0
    150e:	b3 01       	movw	r22, r6
    1510:	0e 94 ac 0a 	call	0x1558	; 0x1558 <fputc>
    1514:	ea 94       	dec	r14
    1516:	ee 20       	and	r14, r14
    1518:	c1 f7       	brne	.-16     	; 0x150a <vfprintf+0x398>
    151a:	43 ce       	rjmp	.-890    	; 0x11a2 <vfprintf+0x30>
    151c:	f3 01       	movw	r30, r6
    151e:	66 81       	ldd	r22, Z+6	; 0x06
    1520:	77 81       	ldd	r23, Z+7	; 0x07
    1522:	cb 01       	movw	r24, r22
    1524:	2b 96       	adiw	r28, 0x0b	; 11
    1526:	e2 e1       	ldi	r30, 0x12	; 18
    1528:	0c 94 52 0b 	jmp	0x16a4	; 0x16a4 <__epilogue_restores__>

0000152c <strnlen_P>:
    152c:	fc 01       	movw	r30, r24
    152e:	05 90       	lpm	r0, Z+
    1530:	61 50       	subi	r22, 0x01	; 1
    1532:	70 40       	sbci	r23, 0x00	; 0
    1534:	01 10       	cpse	r0, r1
    1536:	d8 f7       	brcc	.-10     	; 0x152e <strnlen_P+0x2>
    1538:	80 95       	com	r24
    153a:	90 95       	com	r25
    153c:	8e 0f       	add	r24, r30
    153e:	9f 1f       	adc	r25, r31
    1540:	08 95       	ret

00001542 <strnlen>:
    1542:	fc 01       	movw	r30, r24
    1544:	61 50       	subi	r22, 0x01	; 1
    1546:	70 40       	sbci	r23, 0x00	; 0
    1548:	01 90       	ld	r0, Z+
    154a:	01 10       	cpse	r0, r1
    154c:	d8 f7       	brcc	.-10     	; 0x1544 <strnlen+0x2>
    154e:	80 95       	com	r24
    1550:	90 95       	com	r25
    1552:	8e 0f       	add	r24, r30
    1554:	9f 1f       	adc	r25, r31
    1556:	08 95       	ret

00001558 <fputc>:
    1558:	0f 93       	push	r16
    155a:	1f 93       	push	r17
    155c:	cf 93       	push	r28
    155e:	df 93       	push	r29
    1560:	8c 01       	movw	r16, r24
    1562:	eb 01       	movw	r28, r22
    1564:	8b 81       	ldd	r24, Y+3	; 0x03
    1566:	81 ff       	sbrs	r24, 1
    1568:	1b c0       	rjmp	.+54     	; 0x15a0 <fputc+0x48>
    156a:	82 ff       	sbrs	r24, 2
    156c:	0d c0       	rjmp	.+26     	; 0x1588 <fputc+0x30>
    156e:	2e 81       	ldd	r18, Y+6	; 0x06
    1570:	3f 81       	ldd	r19, Y+7	; 0x07
    1572:	8c 81       	ldd	r24, Y+4	; 0x04
    1574:	9d 81       	ldd	r25, Y+5	; 0x05
    1576:	28 17       	cp	r18, r24
    1578:	39 07       	cpc	r19, r25
    157a:	64 f4       	brge	.+24     	; 0x1594 <fputc+0x3c>
    157c:	e8 81       	ld	r30, Y
    157e:	f9 81       	ldd	r31, Y+1	; 0x01
    1580:	01 93       	st	Z+, r16
    1582:	f9 83       	std	Y+1, r31	; 0x01
    1584:	e8 83       	st	Y, r30
    1586:	06 c0       	rjmp	.+12     	; 0x1594 <fputc+0x3c>
    1588:	e8 85       	ldd	r30, Y+8	; 0x08
    158a:	f9 85       	ldd	r31, Y+9	; 0x09
    158c:	80 2f       	mov	r24, r16
    158e:	09 95       	icall
    1590:	89 2b       	or	r24, r25
    1592:	31 f4       	brne	.+12     	; 0x15a0 <fputc+0x48>
    1594:	8e 81       	ldd	r24, Y+6	; 0x06
    1596:	9f 81       	ldd	r25, Y+7	; 0x07
    1598:	01 96       	adiw	r24, 0x01	; 1
    159a:	9f 83       	std	Y+7, r25	; 0x07
    159c:	8e 83       	std	Y+6, r24	; 0x06
    159e:	02 c0       	rjmp	.+4      	; 0x15a4 <fputc+0x4c>
    15a0:	0f ef       	ldi	r16, 0xFF	; 255
    15a2:	1f ef       	ldi	r17, 0xFF	; 255
    15a4:	c8 01       	movw	r24, r16
    15a6:	df 91       	pop	r29
    15a8:	cf 91       	pop	r28
    15aa:	1f 91       	pop	r17
    15ac:	0f 91       	pop	r16
    15ae:	08 95       	ret

000015b0 <__ultoa_invert>:
    15b0:	fa 01       	movw	r30, r20
    15b2:	aa 27       	eor	r26, r26
    15b4:	28 30       	cpi	r18, 0x08	; 8
    15b6:	51 f1       	breq	.+84     	; 0x160c <__ultoa_invert+0x5c>
    15b8:	20 31       	cpi	r18, 0x10	; 16
    15ba:	81 f1       	breq	.+96     	; 0x161c <__ultoa_invert+0x6c>
    15bc:	e8 94       	clt
    15be:	6f 93       	push	r22
    15c0:	6e 7f       	andi	r22, 0xFE	; 254
    15c2:	6e 5f       	subi	r22, 0xFE	; 254
    15c4:	7f 4f       	sbci	r23, 0xFF	; 255
    15c6:	8f 4f       	sbci	r24, 0xFF	; 255
    15c8:	9f 4f       	sbci	r25, 0xFF	; 255
    15ca:	af 4f       	sbci	r26, 0xFF	; 255
    15cc:	b1 e0       	ldi	r27, 0x01	; 1
    15ce:	3e d0       	rcall	.+124    	; 0x164c <__ultoa_invert+0x9c>
    15d0:	b4 e0       	ldi	r27, 0x04	; 4
    15d2:	3c d0       	rcall	.+120    	; 0x164c <__ultoa_invert+0x9c>
    15d4:	67 0f       	add	r22, r23
    15d6:	78 1f       	adc	r23, r24
    15d8:	89 1f       	adc	r24, r25
    15da:	9a 1f       	adc	r25, r26
    15dc:	a1 1d       	adc	r26, r1
    15de:	68 0f       	add	r22, r24
    15e0:	79 1f       	adc	r23, r25
    15e2:	8a 1f       	adc	r24, r26
    15e4:	91 1d       	adc	r25, r1
    15e6:	a1 1d       	adc	r26, r1
    15e8:	6a 0f       	add	r22, r26
    15ea:	71 1d       	adc	r23, r1
    15ec:	81 1d       	adc	r24, r1
    15ee:	91 1d       	adc	r25, r1
    15f0:	a1 1d       	adc	r26, r1
    15f2:	20 d0       	rcall	.+64     	; 0x1634 <__ultoa_invert+0x84>
    15f4:	09 f4       	brne	.+2      	; 0x15f8 <__ultoa_invert+0x48>
    15f6:	68 94       	set
    15f8:	3f 91       	pop	r19
    15fa:	2a e0       	ldi	r18, 0x0A	; 10
    15fc:	26 9f       	mul	r18, r22
    15fe:	11 24       	eor	r1, r1
    1600:	30 19       	sub	r19, r0
    1602:	30 5d       	subi	r19, 0xD0	; 208
    1604:	31 93       	st	Z+, r19
    1606:	de f6       	brtc	.-74     	; 0x15be <__ultoa_invert+0xe>
    1608:	cf 01       	movw	r24, r30
    160a:	08 95       	ret
    160c:	46 2f       	mov	r20, r22
    160e:	47 70       	andi	r20, 0x07	; 7
    1610:	40 5d       	subi	r20, 0xD0	; 208
    1612:	41 93       	st	Z+, r20
    1614:	b3 e0       	ldi	r27, 0x03	; 3
    1616:	0f d0       	rcall	.+30     	; 0x1636 <__ultoa_invert+0x86>
    1618:	c9 f7       	brne	.-14     	; 0x160c <__ultoa_invert+0x5c>
    161a:	f6 cf       	rjmp	.-20     	; 0x1608 <__ultoa_invert+0x58>
    161c:	46 2f       	mov	r20, r22
    161e:	4f 70       	andi	r20, 0x0F	; 15
    1620:	40 5d       	subi	r20, 0xD0	; 208
    1622:	4a 33       	cpi	r20, 0x3A	; 58
    1624:	18 f0       	brcs	.+6      	; 0x162c <__ultoa_invert+0x7c>
    1626:	49 5d       	subi	r20, 0xD9	; 217
    1628:	31 fd       	sbrc	r19, 1
    162a:	40 52       	subi	r20, 0x20	; 32
    162c:	41 93       	st	Z+, r20
    162e:	02 d0       	rcall	.+4      	; 0x1634 <__ultoa_invert+0x84>
    1630:	a9 f7       	brne	.-22     	; 0x161c <__ultoa_invert+0x6c>
    1632:	ea cf       	rjmp	.-44     	; 0x1608 <__ultoa_invert+0x58>
    1634:	b4 e0       	ldi	r27, 0x04	; 4
    1636:	a6 95       	lsr	r26
    1638:	97 95       	ror	r25
    163a:	87 95       	ror	r24
    163c:	77 95       	ror	r23
    163e:	67 95       	ror	r22
    1640:	ba 95       	dec	r27
    1642:	c9 f7       	brne	.-14     	; 0x1636 <__ultoa_invert+0x86>
    1644:	00 97       	sbiw	r24, 0x00	; 0
    1646:	61 05       	cpc	r22, r1
    1648:	71 05       	cpc	r23, r1
    164a:	08 95       	ret
    164c:	9b 01       	movw	r18, r22
    164e:	ac 01       	movw	r20, r24
    1650:	0a 2e       	mov	r0, r26
    1652:	06 94       	lsr	r0
    1654:	57 95       	ror	r21
    1656:	47 95       	ror	r20
    1658:	37 95       	ror	r19
    165a:	27 95       	ror	r18
    165c:	ba 95       	dec	r27
    165e:	c9 f7       	brne	.-14     	; 0x1652 <__ultoa_invert+0xa2>
    1660:	62 0f       	add	r22, r18
    1662:	73 1f       	adc	r23, r19
    1664:	84 1f       	adc	r24, r20
    1666:	95 1f       	adc	r25, r21
    1668:	a0 1d       	adc	r26, r0
    166a:	08 95       	ret

0000166c <__prologue_saves__>:
    166c:	2f 92       	push	r2
    166e:	3f 92       	push	r3
    1670:	4f 92       	push	r4
    1672:	5f 92       	push	r5
    1674:	6f 92       	push	r6
    1676:	7f 92       	push	r7
    1678:	8f 92       	push	r8
    167a:	9f 92       	push	r9
    167c:	af 92       	push	r10
    167e:	bf 92       	push	r11
    1680:	cf 92       	push	r12
    1682:	df 92       	push	r13
    1684:	ef 92       	push	r14
    1686:	ff 92       	push	r15
    1688:	0f 93       	push	r16
    168a:	1f 93       	push	r17
    168c:	cf 93       	push	r28
    168e:	df 93       	push	r29
    1690:	cd b7       	in	r28, 0x3d	; 61
    1692:	de b7       	in	r29, 0x3e	; 62
    1694:	ca 1b       	sub	r28, r26
    1696:	db 0b       	sbc	r29, r27
    1698:	0f b6       	in	r0, 0x3f	; 63
    169a:	f8 94       	cli
    169c:	de bf       	out	0x3e, r29	; 62
    169e:	0f be       	out	0x3f, r0	; 63
    16a0:	cd bf       	out	0x3d, r28	; 61
    16a2:	09 94       	ijmp

000016a4 <__epilogue_restores__>:
    16a4:	2a 88       	ldd	r2, Y+18	; 0x12
    16a6:	39 88       	ldd	r3, Y+17	; 0x11
    16a8:	48 88       	ldd	r4, Y+16	; 0x10
    16aa:	5f 84       	ldd	r5, Y+15	; 0x0f
    16ac:	6e 84       	ldd	r6, Y+14	; 0x0e
    16ae:	7d 84       	ldd	r7, Y+13	; 0x0d
    16b0:	8c 84       	ldd	r8, Y+12	; 0x0c
    16b2:	9b 84       	ldd	r9, Y+11	; 0x0b
    16b4:	aa 84       	ldd	r10, Y+10	; 0x0a
    16b6:	b9 84       	ldd	r11, Y+9	; 0x09
    16b8:	c8 84       	ldd	r12, Y+8	; 0x08
    16ba:	df 80       	ldd	r13, Y+7	; 0x07
    16bc:	ee 80       	ldd	r14, Y+6	; 0x06
    16be:	fd 80       	ldd	r15, Y+5	; 0x05
    16c0:	0c 81       	ldd	r16, Y+4	; 0x04
    16c2:	1b 81       	ldd	r17, Y+3	; 0x03
    16c4:	aa 81       	ldd	r26, Y+2	; 0x02
    16c6:	b9 81       	ldd	r27, Y+1	; 0x01
    16c8:	ce 0f       	add	r28, r30
    16ca:	d1 1d       	adc	r29, r1
    16cc:	0f b6       	in	r0, 0x3f	; 63
    16ce:	f8 94       	cli
    16d0:	de bf       	out	0x3e, r29	; 62
    16d2:	0f be       	out	0x3f, r0	; 63
    16d4:	cd bf       	out	0x3d, r28	; 61
    16d6:	ed 01       	movw	r28, r26
    16d8:	08 95       	ret

000016da <_exit>:
    16da:	f8 94       	cli

000016dc <__stop_program>:
    16dc:	ff cf       	rjmp	.-2      	; 0x16dc <__stop_program>
