   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 106               	.global	Ports_Zero
 108               	Ports_Zero:
 109               		.stabd	46,0,0
   1:main.c        **** #include <inttypes.h>
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** #include <avr/sleep.h>
   5:main.c        **** 
   6:main.c        **** //#include <util/delay.h>
   7:main.c        **** 
   8:main.c        **** #ifdef GCC_MEGA_AVR
   9:main.c        **** /* EEPROM routines used only with the WinAVR compiler. */
  10:main.c        **** #include <avr/eeprom.h> 
  11:main.c        **** #endif
  12:main.c        **** 
  13:main.c        **** // Needed?
  14:main.c        **** #include <stdlib.h>
  15:main.c        **** #include <string.h>
  16:main.c        **** #include <stdio.h>
  17:main.c        **** 
  18:main.c        **** //#define F_CPU 8E6
  19:main.c        **** 
  20:main.c        **** // Remove
  21:main.c        **** //#include <util/delay.h>
  22:main.c        **** #define MOTION_STEP_DELAY   1000 / MOTION_CONTROL_UPDATE_RATE_HZ
  23:main.c        **** 
  24:main.c        **** #define MOTOR_TEST_EN 0	// If non-zero a repeating pattern will be run .
  25:main.c        **** #define MOTION_TEST_DELAY   1500
  26:main.c        **** #define MOTION_TEST_SPEED1  80
  27:main.c        **** #define MOTION_TEST_TURN1   0
  28:main.c        **** #define MOTION_TEST_SPEED2  80
  29:main.c        **** #define MOTION_TEST_TURN2   80
  30:main.c        **** 
  31:main.c        **** 
  32:main.c        **** #include "base_motion/motors.h"
  33:main.c        **** #include "base_motion/shaft_encoders.h"
  34:main.c        **** #include "base_motion/motion_control.h"
  35:main.c        **** #include "i2c/TWI_slave.h"
  36:main.c        **** 
  37:main.c        **** #include "Avr.h"
  38:main.c        **** #include "i2c_registers.h"
  39:main.c        **** #include "macros.h"
  40:main.c        **** #include "system_clock.h"
  41:main.c        **** 
  42:main.c        **** #define MOT_CMD_ENABLED 1
  43:main.c        **** #define MAX_STEPS_BETWEEN_COMMANDS  25 // 50 Hz Steps (last I checked...)
  44:main.c        **** 
  45:main.c        **** #define I2C_INVALID_VELOCITY    (int16_t)(-32768)
  46:main.c        **** 
  47:main.c        **** volatile I2C_REGISTERS_t* gp_commands_read;
  48:main.c        **** volatile I2C_REGISTERS_t* gp_commands_write;
  49:main.c        **** 
  50:main.c        **** volatile I2C_REGISTERS_t* gp_telemetry_read;
  51:main.c        **** volatile I2C_REGISTERS_t* gp_telemetry_write;
  52:main.c        **** 
  53:main.c        **** static I2C_REGISTERS_t m_commands;
  54:main.c        **** static I2C_REGISTERS_t m_telemetry_a; 
  55:main.c        **** static I2C_REGISTERS_t m_telemetry_b; 
  56:main.c        **** 
  57:main.c        **** void Ports_Zero( void );
  58:main.c        **** 
  59:main.c        **** void Switch_Telemetry_Buffers( void );
  60:main.c        **** 
  61:main.c        **** int main( void )
  62:main.c        **** {
  63:main.c        ****   DISABLE_INTERRUPTS();
  64:main.c        **** 
  65:main.c        ****   SYSTEM_CLOCK_T  motion_step_time = 0;
  66:main.c        ****   uint8_t TWI_slaveAddress = 0x10;
  67:main.c        **** 
  68:main.c        ****   uint8_t steps_since_command = 0;
  69:main.c        **** 
  70:main.c        ****   gp_commands_read = &m_commands;
  71:main.c        ****   gp_commands_write = &m_commands;
  72:main.c        ****   gp_TWI_receive_buf = (uint8_t*)&m_commands;
  73:main.c        **** 
  74:main.c        ****   // After this these pointers are maintained in Switch_Telemetry_Buffer()
  75:main.c        ****   gp_telemetry_read = &m_telemetry_a;
  76:main.c        ****   gp_telemetry_write = &m_telemetry_b;
  77:main.c        ****   gp_TWI_transmitBuf = (uint8_t*)gp_telemetry_read;
  78:main.c        **** 
  79:main.c        **** #if MOTOR_TEST_EN
  80:main.c        ****   SYSTEM_CLOCK_T  motion_test_time = MOTION_TEST_DELAY;
  81:main.c        ****   uint8_t motors_state = 1;
  82:main.c        **** #endif
  83:main.c        **** 
  84:main.c        ****   // Hardware Init
  85:main.c        ****   Ports_Zero();
  86:main.c        ****   Motors_Init();
  87:main.c        **** 
  88:main.c        ****   Motion_Control_Init();
  89:main.c        ****   Shaft_Encoders_Init();
  90:main.c        ****   System_Clock_Init();
  91:main.c        ****   TWI_Slave_Initialise( TWI_slaveAddress << TWI_ADR_BITS );
  92:main.c        ****   TWI_Start_Transceiver();
  93:main.c        **** 
  94:main.c        **** 
  95:main.c        ****   // Turn on the Motors
  96:main.c        **** #if MOT_CMD_ENABLED
  97:main.c        ****   Motors_Enable();
  98:main.c        **** #else
  99:main.c        ****   Motors_Disable();
 100:main.c        **** #endif
 101:main.c        **** 
 102:main.c        ****   ENABLE_INTERRUPTS();
 103:main.c        **** 
 104:main.c        ****   for (;;)
 105:main.c        ****   { 
 106:main.c        ****     if ( Clock_Diff(motion_step_time, g_system_clock) <= 0 )
 107:main.c        ****     {
 108:main.c        ****       Switch_Telemetry_Buffers();
 109:main.c        **** 
 110:main.c        ****       Motion_Control_Run_Step();
 111:main.c        **** 
 112:main.c        ****       motion_step_time += MOTION_STEP_DELAY;
 113:main.c        ****       motion_step_time %= SYSTEM_CLOCK_MAX;
 114:main.c        ****       steps_since_command++;
 115:main.c        **** 
 116:main.c        ****       if ( steps_since_command > MAX_STEPS_BETWEEN_COMMANDS )
 117:main.c        ****       { 
 118:main.c        ****         Motion_Control_Stop();
 119:main.c        ****         steps_since_command = 0;
 120:main.c        ****       }
 121:main.c        ****     }
 122:main.c        **** 
 123:main.c        ****     if ( g_TWI_writeComplete )
 124:main.c        ****     {
 125:main.c        ****       if ( ( gp_commands_read->linear_velocity != I2C_INVALID_VELOCITY ) &&
 126:main.c        ****           ( gp_commands_read->angular_velocity != I2C_INVALID_VELOCITY ) )
 127:main.c        ****       {
 128:main.c        ****         steps_since_command = 0;
 129:main.c        **** 
 130:main.c        ****         Motion_Control_Set_Velocity( gp_commands_read->linear_velocity, 
 131:main.c        ****             gp_commands_read->angular_velocity );
 132:main.c        **** 
 133:main.c        ****         gp_commands_read->linear_velocity = I2C_INVALID_VELOCITY;
 134:main.c        ****         gp_commands_read->angular_velocity = I2C_INVALID_VELOCITY;
 135:main.c        ****       }
 136:main.c        **** 
 137:main.c        ****       g_TWI_writeComplete = false;
 138:main.c        ****     }
 139:main.c        **** 
 140:main.c        **** #if MOTOR_TEST_EN
 141:main.c        ****     if ( Clock_Diff(motion_test_time, g_system_clock) <= 0 )
 142:main.c        ****     {
 143:main.c        ****       if (motors_state)
 144:main.c        ****       {
 145:main.c        ****         Motion_Control_Set_Velocity( MOTION_TEST_SPEED1, MOTION_TEST_TURN1 );
 146:main.c        ****       }
 147:main.c        ****       else
 148:main.c        ****       {
 149:main.c        ****         Motion_Control_Set_Velocity( MOTION_TEST_SPEED2, MOTION_TEST_TURN2 );
 150:main.c        ****       }
 151:main.c        **** 
 152:main.c        ****       motors_state = !motors_state;
 153:main.c        **** 
 154:main.c        ****       motion_test_time += MOTION_TEST_DELAY;
 155:main.c        ****       motion_test_time %= SYSTEM_CLOCK_MAX;
 156:main.c        ****     }
 157:main.c        **** #endif
 158:main.c        ****   }
 159:main.c        ****   // Never reached.
 160:main.c        ****   return(0);
 161:main.c        **** }
 162:main.c        **** 
 163:main.c        **** void Ports_Zero()
 164:main.c        **** {
 111               	.LM0:
 112               	.LFBB1:
 113               	/* prologue: function */
 114               	/* frame size = 0 */
 165:main.c        ****   // Disable interupts
 166:main.c        ****   //cli();
 167:main.c        **** 
 168:main.c        ****   PORTB = 0;
 116               	.LM1:
 117 0000 15B8      		out 37-32,__zero_reg__
 169:main.c        ****   DDRB =  0;
 119               	.LM2:
 120 0002 14B8      		out 36-32,__zero_reg__
 170:main.c        ****   PORTC = 0;
 122               	.LM3:
 123 0004 18B8      		out 40-32,__zero_reg__
 171:main.c        ****   DDRC =  0;
 125               	.LM4:
 126 0006 17B8      		out 39-32,__zero_reg__
 172:main.c        ****   PORTD = 0;
 128               	.LM5:
 129 0008 1BB8      		out 43-32,__zero_reg__
 173:main.c        ****   DDRD =  0;
 131               	.LM6:
 132 000a 1AB8      		out 42-32,__zero_reg__
 133               	/* epilogue start */
 174:main.c        **** 
 175:main.c        ****   // Enable interupts
 176:main.c        ****   //sei();
 177:main.c        **** }
 135               	.LM7:
 136 000c 0895      		ret
 138               	.Lscope1:
 140               		.stabd	78,0,0
 142               	.global	Switch_Telemetry_Buffers
 144               	Switch_Telemetry_Buffers:
 145               		.stabd	46,0,0
 178:main.c        **** 
 179:main.c        **** void Switch_Telemetry_Buffers( void )
 180:main.c        **** {
 147               	.LM8:
 148               	.LFBB2:
 149               	/* prologue: function */
 150               	/* frame size = 0 */
 181:main.c        ****   static uint8_t reading_telemetry_a = true;
 182:main.c        **** 
 183:main.c        ****   DISABLE_INTERRUPTS();
 152               	.LM9:
 153               	/* #APP */
 154               	 ;  183 "main.c" 1
 155 000e F894      		cli
 156               	 ;  0 "" 2
 184:main.c        **** 
 185:main.c        ****   // Make sure we are not currently being read
 186:main.c        ****   if ( !g_TWI_readInProgress )
 158               	.LM10:
 159               	/* #NOAPP */
 160 0010 8091 0000 		lds r24,g_TWI_readInProgress
 161 0014 8823      		tst r24
 162 0016 01F4      		brne .L4
 187:main.c        ****   {
 188:main.c        ****     if ( reading_telemetry_a )
 164               	.LM11:
 165 0018 8091 0000 		lds r24,reading_telemetry_a.1811
 166 001c 40E0      		ldi r20,lo8(m_telemetry_b)
 167 001e 50E0      		ldi r21,hi8(m_telemetry_b)
 168 0020 20E0      		ldi r18,lo8(m_telemetry_a)
 169 0022 30E0      		ldi r19,hi8(m_telemetry_a)
 170 0024 8823      		tst r24
 171 0026 01F0      		breq .L5
 189:main.c        ****     {
 190:main.c        ****       gp_telemetry_read = &m_telemetry_b;
 173               	.LM12:
 174 0028 5093 0000 		sts (gp_telemetry_read)+1,r21
 175 002c 4093 0000 		sts gp_telemetry_read,r20
 191:main.c        ****       gp_telemetry_write = &m_telemetry_a;
 177               	.LM13:
 178 0030 3093 0000 		sts (gp_telemetry_write)+1,r19
 179 0034 2093 0000 		sts gp_telemetry_write,r18
 192:main.c        **** 
 193:main.c        ****       reading_telemetry_a = false;
 181               	.LM14:
 182 0038 1092 0000 		sts reading_telemetry_a.1811,__zero_reg__
 183 003c 00C0      		rjmp .L6
 184               	.L5:
 194:main.c        ****     }
 195:main.c        ****     else
 196:main.c        ****     {
 197:main.c        ****       gp_telemetry_read = &m_telemetry_a;
 186               	.LM15:
 187 003e 3093 0000 		sts (gp_telemetry_read)+1,r19
 188 0042 2093 0000 		sts gp_telemetry_read,r18
 198:main.c        ****       gp_telemetry_write = &m_telemetry_b;
 190               	.LM16:
 191 0046 5093 0000 		sts (gp_telemetry_write)+1,r21
 192 004a 4093 0000 		sts gp_telemetry_write,r20
 199:main.c        **** 
 200:main.c        ****       reading_telemetry_a = true;
 194               	.LM17:
 195 004e 81E0      		ldi r24,lo8(1)
 196 0050 8093 0000 		sts reading_telemetry_a.1811,r24
 197               	.L6:
 201:main.c        ****     }
 202:main.c        **** 
 203:main.c        ****     // Do this here because of the interrupt wrappers
 204:main.c        ****     gp_TWI_transmitBuf = (uint8_t*)gp_telemetry_read;
 199               	.LM18:
 200 0054 8091 0000 		lds r24,gp_telemetry_read
 201 0058 9091 0000 		lds r25,(gp_telemetry_read)+1
 202 005c 9093 0000 		sts (gp_TWI_transmitBuf)+1,r25
 203 0060 8093 0000 		sts gp_TWI_transmitBuf,r24
 204               	.L4:
 205:main.c        ****   }
 206:main.c        **** 
 207:main.c        ****   ENABLE_INTERRUPTS();
 206               	.LM19:
 207               	/* #APP */
 208               	 ;  207 "main.c" 1
 209 0064 7894      		sei
 210               	 ;  0 "" 2
 211               	/* epilogue start */
 208:main.c        **** }
 213               	.LM20:
 214               	/* #NOAPP */
 215 0066 0895      		ret
 220               	.Lscope2:
 222               		.stabd	78,0,0
 226               	.global	HwBitTestAndClear
 228               	HwBitTestAndClear:
 229               		.stabd	46,0,0
 209:main.c        **** 
 210:main.c        **** uint8_t HwBitTestAndClear(uint8_t *data, uint8_t bitNumber)
 211:main.c        **** {   
 231               	.LM21:
 232               	.LFBB3:
 233               	/* prologue: function */
 234               	/* frame size = 0 */
 235 0068 FC01      		movw r30,r24
 212:main.c        ****   uint8_t bitClear;
 213:main.c        ****   cli();
 237               	.LM22:
 238               	/* #APP */
 239               	 ;  213 "main.c" 1
 240 006a F894      		cli
 241               	 ;  0 "" 2
 214:main.c        ****   bitClear = BIT_TEST(*data, bitNumber); 
 243               	.LM23:
 244               	/* #NOAPP */
 245 006c 9081      		ld r25,Z
 246 006e 21E0      		ldi r18,lo8(1)
 247 0070 30E0      		ldi r19,hi8(1)
 248 0072 00C0      		rjmp 2f
 249 0074 220F      	1:	lsl r18
 250 0076 331F      		rol r19
 251 0078 6A95      	2:	dec r22
 252 007a 02F4      		brpl 1b
 215:main.c        ****   BIT_CLEAR(*data, bitNumber);
 254               	.LM24:
 255 007c 822F      		mov r24,r18
 256 007e 8095      		com r24
 257 0080 8923      		and r24,r25
 258 0082 8083      		st Z,r24
 216:main.c        ****   sei();
 260               	.LM25:
 261               	/* #APP */
 262               	 ;  216 "main.c" 1
 263 0084 7894      		sei
 264               	 ;  0 "" 2
 265               	/* #NOAPP */
 266 0086 892F      		mov r24,r25
 267 0088 8223      		and r24,r18
 268 008a 01F0      		breq .L9
 269 008c 81E0      		ldi r24,lo8(1)
 270               	.L9:
 217:main.c        ****   return bitClear;
 218:main.c        **** }
 272               	.LM26:
 273 008e 0895      		ret
 275               	.Lscope3:
 277               		.stabd	78,0,0
 279               	.global	main
 281               	main:
 282               		.stabd	46,0,0
  62:main.c        **** {
 284               	.LM27:
 285               	.LFBB4:
 286 0090 EF92      		push r14
 287 0092 FF92      		push r15
 288 0094 1F93      		push r17
 289 0096 CF93      		push r28
 290 0098 DF93      		push r29
 291               	/* prologue: function */
 292               	/* frame size = 0 */
  63:main.c        ****   DISABLE_INTERRUPTS();
 294               	.LM28:
 295               	/* #APP */
 296               	 ;  63 "main.c" 1
 297 009a F894      		cli
 298               	 ;  0 "" 2
  70:main.c        ****   gp_commands_read = &m_commands;
 300               	.LM29:
 301               	/* #NOAPP */
 302 009c 80E0      		ldi r24,lo8(m_commands)
 303 009e 90E0      		ldi r25,hi8(m_commands)
 304 00a0 9093 0000 		sts (gp_commands_read)+1,r25
 305 00a4 8093 0000 		sts gp_commands_read,r24
  71:main.c        ****   gp_commands_write = &m_commands;
 307               	.LM30:
 308 00a8 9093 0000 		sts (gp_commands_write)+1,r25
 309 00ac 8093 0000 		sts gp_commands_write,r24
  72:main.c        ****   gp_TWI_receive_buf = (uint8_t*)&m_commands;
 311               	.LM31:
 312 00b0 9093 0000 		sts (gp_TWI_receive_buf)+1,r25
 313 00b4 8093 0000 		sts gp_TWI_receive_buf,r24
  75:main.c        ****   gp_telemetry_read = &m_telemetry_a;
 315               	.LM32:
 316 00b8 20E0      		ldi r18,lo8(m_telemetry_a)
 317 00ba 30E0      		ldi r19,hi8(m_telemetry_a)
 318 00bc 3093 0000 		sts (gp_telemetry_read)+1,r19
 319 00c0 2093 0000 		sts gp_telemetry_read,r18
  76:main.c        ****   gp_telemetry_write = &m_telemetry_b;
 321               	.LM33:
 322 00c4 80E0      		ldi r24,lo8(m_telemetry_b)
 323 00c6 90E0      		ldi r25,hi8(m_telemetry_b)
 324 00c8 9093 0000 		sts (gp_telemetry_write)+1,r25
 325 00cc 8093 0000 		sts gp_telemetry_write,r24
  77:main.c        ****   gp_TWI_transmitBuf = (uint8_t*)gp_telemetry_read;
 327               	.LM34:
 328 00d0 3093 0000 		sts (gp_TWI_transmitBuf)+1,r19
 329 00d4 2093 0000 		sts gp_TWI_transmitBuf,r18
  85:main.c        ****   Ports_Zero();
 331               	.LM35:
 332 00d8 0E94 0000 		call Ports_Zero
  86:main.c        ****   Motors_Init();
 334               	.LM36:
 335 00dc 0E94 0000 		call Motors_Init
  88:main.c        ****   Motion_Control_Init();
 337               	.LM37:
 338 00e0 0E94 0000 		call Motion_Control_Init
  89:main.c        ****   Shaft_Encoders_Init();
 340               	.LM38:
 341 00e4 0E94 0000 		call Shaft_Encoders_Init
  90:main.c        ****   System_Clock_Init();
 343               	.LM39:
 344 00e8 0E94 0000 		call System_Clock_Init
  91:main.c        ****   TWI_Slave_Initialise( TWI_slaveAddress << TWI_ADR_BITS );
 346               	.LM40:
 347 00ec 80E2      		ldi r24,lo8(32)
 348 00ee 0E94 0000 		call TWI_Slave_Initialise
  92:main.c        ****   TWI_Start_Transceiver();
 350               	.LM41:
 351 00f2 0E94 0000 		call TWI_Start_Transceiver
  97:main.c        ****   Motors_Enable();
 353               	.LM42:
 354 00f6 0E94 0000 		call Motors_Enable
 102:main.c        ****   ENABLE_INTERRUPTS();
 356               	.LM43:
 357               	/* #APP */
 358               	 ;  102 "main.c" 1
 359 00fa 7894      		sei
 360               	 ;  0 "" 2
 361               	/* #NOAPP */
 362 00fc C0E0      		ldi r28,lo8(0)
 363 00fe D0E0      		ldi r29,hi8(0)
 364 0100 10E0      		ldi r17,lo8(0)
 133:main.c        ****         gp_commands_read->linear_velocity = I2C_INVALID_VELOCITY;
 366               	.LM44:
 367 0102 E12C      		mov r14,__zero_reg__
 368 0104 80E8      		ldi r24,hi8(-32768)
 369 0106 F82E      		mov r15,r24
 370               	.L18:
 106:main.c        ****     if ( Clock_Diff(motion_step_time, g_system_clock) <= 0 )
 372               	.LM45:
 373 0108 6091 0000 		lds r22,g_system_clock
 374 010c 7091 0000 		lds r23,(g_system_clock)+1
 375 0110 CE01      		movw r24,r28
 376 0112 0E94 0000 		call Clock_Diff
 377 0116 1616      		cp __zero_reg__,r22
 378 0118 1706      		cpc __zero_reg__,r23
 379 011a 1806      		cpc __zero_reg__,r24
 380 011c 1906      		cpc __zero_reg__,r25
 381 011e 04F0      		brlt .L12
 108:main.c        ****       Switch_Telemetry_Buffers();
 383               	.LM46:
 384 0120 0E94 0000 		call Switch_Telemetry_Buffers
 110:main.c        ****       Motion_Control_Run_Step();
 386               	.LM47:
 387 0124 0E94 0000 		call Motion_Control_Run_Step
 113:main.c        ****       motion_step_time %= SYSTEM_CLOCK_MAX;
 389               	.LM48:
 390 0128 CE01      		movw r24,r28
 391 012a 4496      		adiw r24,20
 392 012c 60E6      		ldi r22,lo8(-5536)
 393 012e 7AEE      		ldi r23,hi8(-5536)
 394 0130 0E94 0000 		call __udivmodhi4
 395 0134 EC01      		movw r28,r24
 114:main.c        ****       steps_since_command++;
 397               	.LM49:
 398 0136 1F5F      		subi r17,lo8(-(1))
 116:main.c        ****       if ( steps_since_command > MAX_STEPS_BETWEEN_COMMANDS )
 400               	.LM50:
 401 0138 1A31      		cpi r17,lo8(26)
 402 013a 00F0      		brlo .L12
 118:main.c        ****         Motion_Control_Stop();
 404               	.LM51:
 405 013c 0E94 0000 		call Motion_Control_Stop
 406 0140 10E0      		ldi r17,lo8(0)
 407               	.L12:
 123:main.c        ****     if ( g_TWI_writeComplete )
 409               	.LM52:
 410 0142 8091 0000 		lds r24,g_TWI_writeComplete
 411 0146 8823      		tst r24
 412 0148 01F0      		breq .L18
 125:main.c        ****       if ( ( gp_commands_read->linear_velocity != I2C_INVALID_VELOCITY ) &&
 414               	.LM53:
 415 014a E091 0000 		lds r30,gp_commands_read
 416 014e F091 0000 		lds r31,(gp_commands_read)+1
 417 0152 8081      		ld r24,Z
 418 0154 9181      		ldd r25,Z+1
 419 0156 8050      		subi r24,lo8(-32768)
 420 0158 9048      		sbci r25,hi8(-32768)
 421 015a 01F0      		breq .L14
 422 015c 8281      		ldd r24,Z+2
 423 015e 9381      		ldd r25,Z+3
 424 0160 8050      		subi r24,lo8(-32768)
 425 0162 9048      		sbci r25,hi8(-32768)
 426 0164 01F0      		breq .L14
 130:main.c        ****         Motion_Control_Set_Velocity( gp_commands_read->linear_velocity, 
 428               	.LM54:
 429 0166 8081      		ld r24,Z
 430 0168 9181      		ldd r25,Z+1
 431 016a 6281      		ldd r22,Z+2
 432 016c 7381      		ldd r23,Z+3
 433 016e 0E94 0000 		call Motion_Control_Set_Velocity
 133:main.c        ****         gp_commands_read->linear_velocity = I2C_INVALID_VELOCITY;
 435               	.LM55:
 436 0172 E091 0000 		lds r30,gp_commands_read
 437 0176 F091 0000 		lds r31,(gp_commands_read)+1
 438 017a F182      		std Z+1,r15
 439 017c E082      		st Z,r14
 134:main.c        ****         gp_commands_read->angular_velocity = I2C_INVALID_VELOCITY;
 441               	.LM56:
 442 017e F382      		std Z+3,r15
 443 0180 E282      		std Z+2,r14
 444 0182 10E0      		ldi r17,lo8(0)
 445               	.L14:
 137:main.c        ****       g_TWI_writeComplete = false;
 447               	.LM57:
 448 0184 1092 0000 		sts g_TWI_writeComplete,__zero_reg__
 449 0188 00C0      		rjmp .L18
 455               	.Lscope4:
 457               		.stabd	78,0,0
 458               		.data
 461               	reading_telemetry_a.1811:
 462 0000 01        		.byte	1
 463               		.lcomm m_commands,24
 464               		.lcomm m_telemetry_a,24
 465               		.lcomm m_telemetry_b,24
 466               		.comm gp_commands_read,2,1
 467               		.comm gp_commands_write,2,1
 468               		.comm gp_telemetry_read,2,1
 469               		.comm gp_telemetry_write,2,1
 478               		.text
 480               	.Letext0:
 481               	.global __do_copy_data
 482               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccZVnLb9.s:2      *ABS*:0000003f __SREG__
     /tmp/ccZVnLb9.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccZVnLb9.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccZVnLb9.s:5      *ABS*:00000034 __CCP__
     /tmp/ccZVnLb9.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccZVnLb9.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccZVnLb9.s:108    .text:00000000 Ports_Zero
     /tmp/ccZVnLb9.s:144    .text:0000000e Switch_Telemetry_Buffers
     /tmp/ccZVnLb9.s:461    .data:00000000 reading_telemetry_a.1811
     /tmp/ccZVnLb9.s:464    .bss:00000030 m_telemetry_b
     /tmp/ccZVnLb9.s:463    .bss:00000018 m_telemetry_a
                            *COM*:00000002 gp_telemetry_read
                            *COM*:00000002 gp_telemetry_write
     /tmp/ccZVnLb9.s:228    .text:00000068 HwBitTestAndClear
     /tmp/ccZVnLb9.s:281    .text:00000090 main
                             .bss:00000000 m_commands
                            *COM*:00000002 gp_commands_read
                            *COM*:00000002 gp_commands_write

UNDEFINED SYMBOLS
g_TWI_readInProgress
gp_TWI_transmitBuf
gp_TWI_receive_buf
Motors_Init
Motion_Control_Init
Shaft_Encoders_Init
System_Clock_Init
TWI_Slave_Initialise
TWI_Start_Transceiver
Motors_Enable
g_system_clock
Clock_Diff
Motion_Control_Run_Step
__udivmodhi4
Motion_Control_Stop
g_TWI_writeComplete
Motion_Control_Set_Velocity
__do_copy_data
__do_clear_bss
